local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

local WLP = {
    ["gaigeskywalker1"] = true,
    ["FrogMansALTLOL"] = true,
    ["LackOfAirr"] = true,
    ["ZachPlaysRoblox12332"] = true,
    ["JobsonNumber"] = true,
    ["66hxstxfy"] = true,
    ["QR4TL"] = true,
}

local function displayStyledMessage(message, delay, duration)
    task.spawn(function()
        task.wait(delay)

        local systemMessage = TextChatService.TextChannels.RBXSystem:DisplaySystemMessage(message)

        if duration then
            task.wait(duration)
            if systemMessage and systemMessage.Parent then
                systemMessage:Destroy()
            end
        end
    end)
end

local function showWhitelistSequence(isWhitelisted)
    local messages = {}
    
    if isWhitelisted then
        messages = {
            "<font color='rgb(255,215,85)'><b>[OBSIDIAN]</b></font> <font color='rgb(180,255,180)'>Initializing client...</font>",
            "<font color='rgb(255,215,85)'><b>[OBSIDIAN]</b></font> <font color='rgb(180,255,180)'>Whitelist verified. Welcome back, <b>" .. LocalPlayer.Name .. "</b>!</font>",
        }
    else
        messages = {
            "<font color='rgb(255,100,100)'><b>[OBSIDIAN]</b></font> <font color='rgb(255,180,180)'>Access denied.</font>",
            "<font color='rgb(255,100,100)'><b>[OBSIDIAN]</b></font> <font color='rgb(255,180,180)'>You are not whitelisted for this client.</font>",
            "<font color='rgb(255,100,100)'><b>[OBSIDIAN]</b></font> <font color='rgb(255,180,180)'>Exiting in 5 seconds...</font>"
        }
    end

    local delayTime = 0
    for _, msg in ipairs(messages) do
        displayStyledMessage(msg, delayTime, 6)
        delayTime = delayTime + 6
    end

    if not isWhitelisted then
        task.delay(delayTime + 0.5, function()
            LocalPlayer:Kick("OBSIDIAN CLIENT\n\nYou are not whitelisted.\n\nContact the developer if this is a mistake.\n\n@vira")
        end)
    end
end

showWhitelistSequence(WLP[LocalPlayer.Name])

local mainMessages = {
    "<b>[OBSIDIAN]</b> <i>Initializing modules...</i>",
    "<b>[OBSIDIAN]</b> <i>Loading premium features...</i>",
    "<b>[OBSIDIAN]</b> <i>Optimizing performance...</i>",
    "<b>[OBSIDIAN]</b> <i>Applying theme settings...</i>",
    "<b>[OBSIDIAN]</b> <i>Finalizing...</i>",
    "<b>[OBSIDIAN]</b> <i>Obsidian Loaded Successfully!</i>",
    "<b>[OBSIDIAN]</b> <i>Created by <b>vira</b>. Shoutout to testers: Jake, Loopy, MrLoopy, QR4TL</i>"
}

task.spawn(function()
    local delayTime = 0
    for i, msg in ipairs(mainMessages) do
        displayMessage(msg, delayTime, 6, i > 3)
        delayTime = delayTime + 6
    end
end)

if game:GetService("CoreGui") then
    local TweenService = game:GetService("TweenService")
    local TopbarNotify = Instance.new("TextLabel")
    TopbarNotify.Size = UDim2.new(1,0,0,36)
    TopbarNotify.Position = UDim2.new(0,0,-1,0)
    TopbarNotify.BackgroundColor3 = Color3.fromRGB(20,20,20)
    TopbarNotify.TextColor3 = Color3.fromRGB(255,255,255)
    TopbarNotify.Font = Enum.Font.GothamBold
    TopbarNotify.TextSize = 18
    TopbarNotify.Text = "Obsidian Client is loading..."
    TopbarNotify.Parent = game:GetService("CoreGui")

    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(TopbarNotify, tweenInfo, {Position = UDim2.new(0,0,0,0)}):Play()

    task.delay(6, function()
        TweenService:Create(TopbarNotify, tweenInfo, {Position = UDim2.new(0,0,-1,0)}):Play()
        task.delay(0.5, function()
            TopbarNotify:Destroy()
        end)
    end)
end

game:GetService("Workspace").Terrain.Clouds.Density = 0.5709999799728394
            game:GetService("Workspace").Terrain.Clouds.Cover = 0.5709999799728394
            game:GetService("Lighting").Brightness = 2
            game:GetService("Lighting").FogColor = Color3.fromRGB(192,192,192)
            game:GetService("Lighting").ClockTime = 14
            game:GetService("Lighting").FogEnd = 100000
            game:GetService("Lighting").FogStart = 0
            game:GetService("Lighting").Sky.SkyboxBk = "rbxassetid://8995816670"
            game:GetService("Lighting").Sky.SkyboxDn = "rbxassetid://8995686153"
            game:GetService("Lighting").Sky.SkyboxFt = "rbxassetid://8995816670"
            game:GetService("Lighting").Sky.SkyboxLf = "rbxassetid://8995816670"
            game:GetService("Lighting").Sky.SkyboxRt = "rbxassetid://8995816670"
            game:GetService("Lighting").Sky.SkyboxUp = "rbxassetid://8995814929"

local Sound = Instance.new("Sound")
Sound.SoundId = "rbxassetid://9118823260"
Sound.Volume = 0.3
Sound.PlayOnRemove = true
Sound.Parent = workspace
Sound:Destroy()

loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "OBSIDIAN - CLIENT",
   LoadingTitle = "OBSIDIAN",
   LoadingSubtitle = "Loading...",
   ShowText = "OBS",
   Theme = {
       TextColor = Color3.fromRGB(255, 255, 255),
       PlaceholderColor = Color3.fromRGB(200, 200, 200),

       Background = Color3.fromRGB(15, 15, 25),
       Topbar = Color3.fromRGB(25, 25, 50),
       Shadow = Color3.fromRGB(0, 0, 0),

       NotificationBackground = Color3.fromRGB(30, 30, 60), 
       NotificationActionsBackground = Color3.fromRGB(60, 60, 120),

       TabBackground = Color3.fromRGB(20, 20, 40),
       TabStroke = Color3.fromRGB(80, 80, 160),
       TabBackgroundSelected = Color3.fromRGB(70, 0, 200),
       TabTextColor = Color3.fromRGB(180, 180, 255),
       SelectedTabTextColor = Color3.fromRGB(255, 255, 255),

       ElementBackground = Color3.fromRGB(35, 35, 60),
       ElementBackgroundHover = Color3.fromRGB(60, 60, 120), 
       SecondaryElementBackground = Color3.fromRGB(25, 25, 50),

       ElementStroke = Color3.fromRGB(120, 0, 255),
       SecondaryElementStroke = Color3.fromRGB(80, 80, 160),

       SliderBackground = Color3.fromRGB(50, 50, 100),
       SliderProgress = Color3.fromRGB(0, 255, 255),
       SliderStroke = Color3.fromRGB(120, 0, 255),

       ToggleBackground = Color3.fromRGB(50, 50, 100),
       ToggleEnabled = Color3.fromRGB(0, 255, 128),
       ToggleDisabled = Color3.fromRGB(100, 100, 100),

       ToggleEnabledStroke = Color3.fromRGB(0, 200, 100),
       ToggleDisabledStroke = Color3.fromRGB(150, 50, 50),

       ToggleEnabledOuterStroke = Color3.fromRGB(0, 255, 128),
       ToggleDisabledOuterStroke = Color3.fromRGB(80, 80, 80),

       DropdownSelected = Color3.fromRGB(60, 60, 120),
       DropdownUnselected = Color3.fromRGB(35, 35, 60),

       InputBackground = Color3.fromRGB(35, 35, 60),
       InputStroke = Color3.fromRGB(120, 0, 255),
   },

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = true,
   FreeMouse = true,

   ConfigurationSaving = {
      Enabled = true,
      FolderName = "Obsidian",
      FileName = "Internal"
   },

   Discord = {
      Enabled = false
   },

   KeySystem = false,
})

local BlobkickList = {"BarnoDDino","ay3vx"}
local BKA = false
local BKAWL = true
local blob = nil
local WS = 1

local AGE = false
local AFE = false
local AXE = false
local AKE = false
local APKE = false
local antiok = true
local antiblob = false
local antibanana = false
local antiboid = false
local ALAGE = false
local RDAAG = false
local antifirepart = nil

if game.workspace.Plots.Plot5.Barrier:FindFirstChild("AntiFirePart") then	
	antifirepart = game.workspace.Plots.Plot5.Barrier["AntiFirePart"]
else
	antifirepart = game.workspace.Plots.Plot5.Barrier:FindFirstChild("PlotBarrier")
end
antifirepart.CanCollide = true
antifirepart.CanQuery = true
antifirepart.Name = "AntiFirePart"
local h = antifirepart:Clone()
h.Name = "FalseBorder"
h.Parent = antifirepart.Parent
antifirepart.Size = Vector3.new(1,1,1)
for _,prt in pairs(antifirepart:GetChildren()) do
	prt:Destroy()
end
antifirepart.CanQuery = false
antifirepart.CanCollide = false

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

localPlayer.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")
    humanoidRootPart = char:WaitForChild("HumanoidRootPart")
end)

local MainTab = Window:CreateTab("Main", 6023426915)

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

local character, humanoid, humanoidRootPart

local function updateCharacterParts()
    character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
end

updateCharacterParts()
LocalPlayer.CharacterAdded:Connect(updateCharacterParts)

-- Variables for toggles/sliders
local autoRejoinEnabled = false
local tpwalking = false
local tspeed = 0.1
local infJumpConnection = nil
local infJumpDebounce = false

local originalMaxZoom = LocalPlayer.CameraMaxZoomDistance
local originalMinZoom = LocalPlayer.CameraMinZoomDistance
local originalCameraMode = LocalPlayer.CameraMode

local function lerpVector3(a, b, alpha)
    return a + (b - a) * alpha
end

local function safeNotify(opts)
    local success, err = pcall(function()
        Rayfield:Notify(opts)
    end)
    if not success then
        warn("Notify failed:", err)
    end
end

MainTab:CreateSection("Server")

MainTab:CreateParagraph({
    Title = "Current Player",
    Content = string.format("%s (@%s)", LocalPlayer.Name, LocalPlayer.DisplayName)
})

MainTab:CreateButton({
    Name = "Close Script",
    Tooltip = "Closes the entire UI and stops all features.",
    Callback = function()
        safeNotify({
            Title = "Goodbye!",
            Content = "Closing Obsidian UI...",
            Duration = 2,
            Image = 4483362458
        })
        task.wait(1)
        Rayfield:Destroy()
    end,
})

MainTab:CreateButton({
    Name = "Rejoin",
    Tooltip = "Rejoin current server.",
    Callback = function()
        safeNotify({
            Title = "Rejoin",
            Content = "Attempting to rejoin the server...",
            Duration = 4,
            Image = 4483362458,
        })
        task.wait(0.5)
        local success, err = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
        end)
        if not success then
            safeNotify({Title = "Error", Content = "Failed to rejoin: " .. tostring(err), Duration = 4})
        end
    end,
})

MainTab:CreateButton({
    Name = "Server Hop",
    Tooltip = "Finds and teleports to a different server with available slots.",
    Callback = function()
        safeNotify({
            Title = "Server Hop",
            Content = "Fetching available servers...",
            Duration = 3,
            Image = 4483362458,
        })

        task.spawn(function()
            local servers = {}
            local success, response = pcall(function()
                local url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", game.PlaceId)
                return game:HttpGet(url)
            end)

            if success and response then
                local body = HttpService:JSONDecode(response)
                if body and body.data then
                    for _, v in pairs(body.data) do
                        if type(v) == "table" and v.playing and v.maxPlayers and v.id ~= game.JobId and v.playing < v.maxPlayers then
                            table.insert(servers, v.id)
                        end
                    end
                end
            else
                safeNotify({
                    Title = "Server Hop",
                    Content = "Failed to fetch servers.",
                    Duration = 3
                })
                return
            end

            if #servers > 0 then
                local randomServer = servers[math.random(1, #servers)]
                local success2, err2 = pcall(function()
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer, LocalPlayer)
                end)
                if not success2 then
                    safeNotify({Title = "Error", Content = "Server Hop failed: " .. tostring(err2), Duration = 4})
                end
            else
                safeNotify({
                    Title = "Server Hop",
                    Content = "No available servers found.",
                    Duration = 3
                })
            end
        end)
    end,
})

MainTab:CreateToggle({
    Name = "Auto Rejoin",
    Tooltip = "Automatically rejoins server on disconnect or kick.",
    CurrentValue = false,
    Flag = "AutoRejoinToggle",
    Callback = function(state)
        autoRejoinEnabled = state
        safeNotify({
            Title = "Auto Rejoin",
            Content = state and "Enabled" or "Disabled",
            Duration = 3
        })
    end,
})

GuiService.ErrorMessageChanged:Connect(function()
    if autoRejoinEnabled then
        task.spawn(function()
            if #Players:GetPlayers() <= 1 then
                LocalPlayer:Kick("\nAuto Rejoining...")
                task.wait(0.5)
                TeleportService:Teleport(game.PlaceId, LocalPlayer)
            else
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
            end
        end)
    end
end)

MainTab:CreateSection(" Player ")

local lastPosition = nil
local moveLerpAlpha = 0.15

MainTab:CreateToggle({
    Name = "Speed Boost",
    Tooltip = "Boost your movement speed smoothly.",
    CurrentValue = false,
    Flag = "SpeedBoostToggle",
    Callback = function(value)
        tpwalking = value
        if not tpwalking then
        end
    end,
})

local speedSlider = MainTab:CreateSlider({
    Name = "Speed",
    Range = {0.1, 10},
    Increment = 0.1,
    Suffix = " studs/sec",
    CurrentValue = tspeed,
    Flag = "SpeedBoostSlider",
    Callback = function(value)
        tspeed = value
    end,
})

RunService.Heartbeat:Connect(function()
    if tpwalking and character and humanoid and humanoidRootPart then
        local moveDir = humanoid.MoveDirection
        if moveDir.Magnitude > 0 then
            local targetCFrame = humanoidRootPart.CFrame + (moveDir * tspeed)
            humanoidRootPart.CFrame = humanoidRootPart.CFrame:Lerp(targetCFrame, moveLerpAlpha)
        end
    end
end)

MainTab:CreateToggle({
    Name = "Jump Boost",
    Tooltip = "Increase your jump height.",
    CurrentValue = false,
    Flag = "JumpBoostToggle",
    Callback = function(value)
        if humanoid then
            humanoid.UseJumpPower = not value
            if not value then
                -- Reset jump height to default
                humanoid.JumpHeight = 7.2
            end
        end
    end,
})

MainTab:CreateSlider({
    Name = "Jump Height",
    Range = {7.2, 500},
    Increment = 0.1,
    Suffix = " studs",
    CurrentValue = humanoid and humanoid.JumpHeight or 7.2,
    Flag = "JumpBoostSlider",
    Callback = function(value)
        if humanoid then
            humanoid.JumpHeight = value
        end
    end,
})

MainTab:CreateToggle({
    Name = "Infinite Jump",
    Tooltip = "Allows you to jump infinitely by pressing spacebar.",
    CurrentValue = false,
    Flag = "InfiniteJumpToggle",
    Callback = function(value)
        if infJumpConnection then
            infJumpConnection:Disconnect()
            infJumpConnection = nil
        end

        if value then
            infJumpDebounce = false
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                if not infJumpDebounce and humanoid then
                    infJumpDebounce = true
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait()
                    infJumpDebounce = false
                end
            end)
        end
    end,
})

MainTab:CreateSlider({
    Name = "Gravity",
    Tooltip = "Adjust the world's gravity (default 196.2).",
    Range = {0, 300},
    Increment = 0.1,
    Suffix = " studs/sÂ²",
    CurrentValue = workspace.Gravity,
    Flag = "GravitySlider",
    Callback = function(value)
        local currentGravity = workspace.Gravity
        local targetGravity = value
        spawn(function()
            local steps = 15
            for i = 1, steps do
                workspace.Gravity = currentGravity + ((targetGravity - currentGravity) * (i / steps))
                task.wait(0.02)
            end
            workspace.Gravity = targetGravity
        end)
    end,
})

MainTab:CreateSlider({
    Name = "Field of View (FOV)",
    Tooltip = "Change your camera's field of view for better vision.",
    Range = {70, 120},
    Increment = 0.1,
    Suffix = " degrees",
    CurrentValue = workspace.CurrentCamera.FieldOfView,
    Flag = "FOVSlider",
    Callback = function(value)
        local camera = workspace.CurrentCamera
        local startFOV = camera.FieldOfView
        local targetFOV = value
        spawn(function()
            local steps = 15
            for i = 1, steps do
                camera.FieldOfView = startFOV + ((targetFOV - startFOV) * (i / steps))
                task.wait(0.02)
            end
            camera.FieldOfView = targetFOV
        end)
    end,
})

MainTab:CreateToggle({
    Name = "Third Person",
    Tooltip = "Toggle third-person camera mode with infinite zoom.",
    CurrentValue = false,
    Flag = "ThirdPersonToggle",
    Callback = function(value)
        if value then
            originalMaxZoom = LocalPlayer.CameraMaxZoomDistance
            originalMinZoom = LocalPlayer.CameraMinZoomDistance
            originalCameraMode = LocalPlayer.CameraMode

            LocalPlayer.CameraMaxZoomDistance = math.huge
            LocalPlayer.CameraMinZoomDistance = 0.5
            LocalPlayer.CameraMode = Enum.CameraMode.Classic
        else
            LocalPlayer.CameraMaxZoomDistance = originalMaxZoom
            LocalPlayer.CameraMinZoomDistance = originalMinZoom
            LocalPlayer.CameraMode = originalCameraMode
        end
    end,
})

MainTab:CreateSection(" Helper ")

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Workspace = game:GetService("Workspace")
UserInputService = game:GetService("UserInputService")
GuiService = game:GetService("GuiService")
me = Players.LocalPlayer
Mouse = me:GetMouse()
hrp = HumanoidRootPart
Root = RootPart
CamPart = CamPart
FWC = nil
char = Players.LocalPlayer.Character

function FWC(parent, childName)
    return parent:FindFirstChild(childName)
end

GetClosestPlayerFromCursor = function()
    if Mouse.Target then
        local target = Mouse.Target.Parent
        for _, v in pairs(Players:GetPlayers()) do
            if v.Name == target.Name then
                return v.Name
            end
        end
    end
    local found = nil
    local ClosestDistance = math.huge
    for i, v in pairs(Players:GetPlayers()) do
        if v ~= me and v.Character and v.Character:FindFirstChildOfClass("Humanoid") then
            for k, x in pairs(v.Character:GetChildren()) do
                if string.find(x.Name, "HumanoidRootPart") then
                    local Distance = (WorldToScreen(x) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                    if Distance < ClosestDistance then
                        ClosestDistance = Distance
                        found = v
                    end
                end
            end
        end
    end
    return found
end

task.defer(function()
    local char = me.Character or me.CharacterAdded:wait()
    local hrp = char and FWC(char, "HumanoidRootPart", 3)
    local Root = hrp and FWC(hrp, "RootAttachment", 3)
    local CamPart = char and FWC(char, "CamPart", 3)
    if Root and CamPart then
        Root.Parent = CamPart
    end
end)

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Workspace = game:GetService("Workspace")
UserInputService = game:GetService("UserInputService")
GuiService = game:GetService("GuiService")
me = Players.LocalPlayer
Mouse = me:GetMouse()
hrp = HumanoidRootPart
Root = RootPart
CamPart = CamPart
FWC = nil
char = Players.LocalPlayer.Character

function FWC(parent, childName)
    return parent:FindFirstChild(childName)
end

GetClosestPlayerFromCursor = function()
    if Mouse.Target then
        local target = Mouse.Target.Parent
        for _, v in pairs(Players:GetPlayers()) do
            if v.Name == target.Name then
                return v.Name
            end
        end
    end
    local found = nil
    local ClosestDistance = math.huge
    for i, v in pairs(Players:GetPlayers()) do
        if v ~= me and v.Character and v.Character:FindFirstChildOfClass("Humanoid") then
            for k, x in pairs(v.Character:GetChildren()) do
                if string.find(x.Name, "HumanoidRootPart") then
                    local Distance = (WorldToScreen(x) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                    if Distance < ClosestDistance then
                        ClosestDistance = Distance
                        found = v
                    end
                end
            end
        end
    end
    return found
end

task.defer(function()
    local char = me.Character or me.CharacterAdded:wait()
    local hrp = char and FWC(char, "HumanoidRootPart", 3)
    local Root = hrp and FWC(hrp, "RootAttachment", 3)
    local CamPart = char and FWC(char, "CamPart", 3)
    if Root and CamPart then
        Root.Parent = CamPart
    end
end)

Keybind = MainTab:CreateKeybind({
    Name = "Click TP",
    CurrentKeybind = "Z",
    HoldToInteract = false,
    Flag = "ClickTP",
    Callback = function(Keybind)
        if Mouse.Target then
            local char = me.Character
            if not char.Head.BallSocketConstraint.Enabled then
                char.HumanoidRootPart.CFrame = Mouse.Hit + Vector3.new(0, 3, 0)
                for _, v in pairs(char:GetChildren()) do
                    if v:IsA("BasePart") then
                        v.Velocity = Vector3.new()
                    end
                end
            else
                for _, v in pairs(char:GetChildren()) do
                    if v:IsA("BasePart") then
                        v.CFrame = Mouse.Hit + Vector3.new(0, 2.15, 0)
                    end
                end
                for _, v in pairs(char:GetChildren()) do
                    if v:IsA("BasePart") then
                        v.Velocity = Vector3.new()
                    end
                end
            end
        end
    end,
})


MainTab:CreateKeybind({
    Name = "Stop Velocity",
    CurrentKeybind = "G",
    HoldToInteract = false,
    Flag = "StopVelocityKeybind",
    Callback = function()
        if character and humanoidRootPart then
            humanoidRootPart.AssemblyLinearVelocity = Vector3.new()
        end
    end
})

MainTab:CreateToggle({
    Name = "Water Walk",
    CurrentValue = false,
    Flag = "WaterWalkToggle",
    Callback = function(Value)
        local ocean = Workspace:FindFirstChild("Map")
            and Workspace.Map:FindFirstChild("AlwaysHereTweenedObjects")
            and Workspace.Map.AlwaysHereTweenedObjects:FindFirstChild("Ocean")
            and Workspace.Map.AlwaysHereTweenedObjects.Ocean:FindFirstChild("Object")
            and Workspace.Map.AlwaysHereTweenedObjects.Ocean.Object:FindFirstChild("ObjectModel")

        if ocean then
            for _, part in pairs(ocean:GetChildren()) do
                if part:IsA("BasePart") and part.Name == "Ocean" then
                    part.CanCollide = Value
                end
            end
        end
    end
})

local AntiTab = Window:CreateTab("Protection", "shield")

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
RunService = game:GetService("RunService")
Debris = game:GetService("Debris")
LocalPlayer = Players.LocalPlayer

local defenseEnabled = false
local defenseConnection = nil
local defenseMode = "Fling"

GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")
DestroyGrabLine = GrabEvents:FindFirstChild("DestroyGrabLine")
CreateGrabEvent = GrabEvents:FindFirstChild("CreateGrabLine")

local function getAttacker()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("Head") then return end
    local owner = char.Head:FindFirstChild("PartOwner")
    if not owner or not owner:IsA("StringValue") then return end
    return Players:FindFirstChild(owner.Value)
end

local function performFling(attacker)
    if not attacker or not attacker.Character then return end
    local root = attacker.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    pcall(function()
        SetNetworkOwner:FireServer(root, root.CFrame)
        if DestroyGrabLine then DestroyGrabLine:FireServer(root) end
        local away = (root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Unit
        away = Vector3.new(away.X, 0, away.Z) * 10000
        local bv = Instance.new("BodyVelocity")
        bv.Name = "RinneganFling"
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = away
        bv.P = 12500
        bv.Parent = root
        Debris:AddItem(bv, 0.1)
    end)
end

local function performHeaven(attacker)
    if not attacker or not attacker.Character then return end
    local root = attacker.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    pcall(function()
        SetNetworkOwner:FireServer(root, root.CFrame)
        if DestroyGrabLine then DestroyGrabLine:FireServer(root) end
        root.CFrame = CFrame.new(0, 100, 0)
        local bv = Instance.new("BodyVelocity")
        bv.Name = "RinneganHeaven"
        bv.MaxForce = Vector3.new(0, math.huge, 0)
        bv.Velocity = Vector3.new(0, 100, 0)
        bv.P = 12500
        bv.Parent = root
        Debris:AddItem(bv, 5)
    end)
end

local function performKick(attacker)
    if not attacker or not attacker.Character then return end
    local root = attacker.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    pcall(function()
        SetNetworkOwner:FireServer(root, root.CFrame)
        if DestroyGrabLine then DestroyGrabLine:FireServer(root) end
        root.CFrame = CFrame.new(0, 999999999999, 0)
        local bv = Instance.new("BodyVelocity")
        bv.Name = "RinneganHeaven"
        bv.MaxForce = Vector3.new(0, math.huge, 0)
        bv.Velocity = Vector3.new(0, 99999999999999, 0)
        bv.P = 12500
        bv.Parent = root
        Debris:AddItem(bv, 5)
    end)
end

local function performRagdoll(attacker)
    if not attacker or not attacker.Character then return end
    local root = attacker.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    pcall(function()
        SetNetworkOwner:FireServer(root, root.CFrame)
        if DestroyGrabLine then DestroyGrabLine:FireServer(root) end
        local bv = Instance.new("BodyVelocity")
        bv.Name = "RinneganSpy"
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.new(0, -90, 0)
        bv.P = 12500
        bv.Parent = root
        Debris:AddItem(bv, 0.1)
    end)
end

local function performHell(attacker)
    if not attacker or not attacker.Character then return end
    local root = attacker.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    pcall(function()
        SetNetworkOwner:FireServer(root, root.CFrame)
        if DestroyGrabLine then DestroyGrabLine:FireServer(root) end
        for _, part in ipairs(attacker.Character:GetDescendants()) do
            if part:IsA("BasePart") and not part.Anchored then
                part.CanCollide = false
            end
        end
        local bv = Instance.new("BodyVelocity")
        bv.Name = "RinneganSpy"
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.new(0, -10000000, 0)
        bv.P = 12500
        bv.Parent = root
        local noclipConnection
        noclipConnection = RunService.Heartbeat:Connect(function()
            if not attacker.Character or not attacker.Character.Parent then
                noclipConnection:Disconnect()
                return
            end
            for _, part in ipairs(attacker.Character:GetDescendants()) do
                if part:IsA("BasePart") and not part.Anchored then
                    part.CanCollide = false
                end
            end
        end)
        task.delay(1.5, function()
            if noclipConnection then noclipConnection:Disconnect() end
        end)
        Debris:AddItem(bv, 0.1)
    end)
end

local function performChina(attacker)
    if not attacker or not attacker.Character then return end
    local root = attacker.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    pcall(function()
        SetNetworkOwner:FireServer(root, root.CFrame)
        if DestroyGrabLine then DestroyGrabLine:FireServer(root) end
        root.CFrame = CFrame.new(591, 153, -101)
    end)
end

local crazyline = false
local function performSpamGrabLines(attacker)
    while crazyline do
        local char = LocalPlayer.Character
        if char then
            local head = char:FindFirstChild("Head")
            if head then
                local owner = head:FindFirstChild("PartOwner")
                if owner and owner:IsA("StringValue") then
                    local attacker = Players:FindFirstChild(owner.Value)
                    if attacker and attacker.Character then
                        local attackerHead = attacker.Character:FindFirstChild("Head")
                        local attackerHRP = attacker.Character:FindFirstChild("HumanoidRootPart")
                        if attackerHead and attackerHRP then
                            for i = 1, 3 do
                                pcall(function() CreateGrabEvent:FireServer(attackerHead, attackerHead.CFrame) end)
                            end
                            for i = 1, 3 do
                                pcall(function() CreateGrabEvent:FireServer(attackerHRP, attackerHRP.CFrame) end)
                            end
                        end
                    end
                end
            end
        end
        task.wait(1)
    end
end

local function startDefense()
    if defenseConnection then return end
    defenseConnection = RunService.Heartbeat:Connect(function()
        if not defenseEnabled then return end
        local attacker = getAttacker()
        if not attacker then return end
        if defenseMode == "Fling" then performFling(attacker)
        elseif defenseMode == "Send to Heaven" then performHeaven(attacker)
        elseif defenseMode == "Kick" then performKick(attacker)
        elseif defenseMode == "Ragdoll" then performRagdoll(attacker)
        elseif defenseMode == "Send To Hell" then performHell(attacker)
        elseif defenseMode == "Send To China" then performChina(attacker)
        elseif defenseMode == "Grab-Line" then performSpamGrabLines(attacker)
        end
    end)
end

local function stopDefense()
    if defenseConnection then
        defenseConnection:Disconnect()
        defenseConnection = nil
    end
    for _, plr in ipairs(Players:GetPlayers()) do
        local char = plr.Character
        if char then
            for _, obj in ipairs(char:GetDescendants()) do
                if obj:IsA("BodyVelocity") and (obj.Name == "RinneganFling" or obj.Name == "RinneganHeaven") then
                    obj:Destroy()
                end
            end
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    if defenseEnabled then
        task.wait(1)
        startDefense()
    end
end)

AntiTab:CreateToggle({
    Name = 'Auto-Attack',
    CurrentValue = false,
    Flag = "RinneganDefenseToggle",
    Callback = function(enabled)
        defenseEnabled = enabled
        if enabled then
            startDefense()
        else
            stopDefense()
        end
    end
})

AntiTab:CreateDropdown({
    Name = "Mode",
    Options = {"Fling","Send To Heaven","Kick","Ragdoll","Send To Hell","Send To China","Grab-Line"},
    CurrentOption = "Fling",
    Flag = "RinneganMode",
    Callback = function(mode)
        if typeof(mode) == "table" then mode = mode[1] end
        defenseMode = mode
    end
})

Players = game:GetService("Players")
 RunService = game:GetService("RunService")
 ReplicatedStorage = game:GetService("ReplicatedStorage")
 Workspace = game:GetService("Workspace")
LocalPlayer = Players.LocalPlayer

 GUCCIISTUFF = false
local antiGayConn

function Gucci()
    local Character = LocalPlayer.Character
    if not Character then return end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    if not Humanoid or not RootPart then return end
    
    local PlayerName = LocalPlayer.Name
    local originalCFrame = RootPart.CFrame
    
    local args = {
        [1] = "CreatureBlobman",
        [2] = CFrame.new(0, 50000, 0),
        [3] = Vector3.new(0, 59.667, 0)
    }
    
    pcall(function()
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(unpack(args))
    end)

    local SITFolder = Workspace:WaitForChild(PlayerName .. "SpawnedInToys", 3)
    if not SITFolder then return end

    local daddy = SITFolder:WaitForChild("CreatureBlobman", 2)
    if not daddy then return end

    local head = daddy:FindFirstChild("Head")
    if head then
        head.Anchored = true
        head.CFrame = CFrame.new(0, 50000, 0)
    end

    local seat = daddy:FindFirstChild("VehicleSeat")
    if not seat then return end
    
    RootPart.CFrame = seat.CFrame
    seat:Sit(Humanoid)

    if antiGayConn then
        antiGayConn:Disconnect()
    end

    antiGayConn = RunService.Heartbeat:Connect(function()
        if not GUCCIISTUFF then
            if antiGayConn then
                antiGayConn:Disconnect()
                antiGayConn = nil
            end
            return
        end
        pcall(function()
            ReplicatedStorage.CharacterEvents.RagdollRemote:FireServer(RootPart, 0)
        end)
    end)
    
    task.wait(0.15)
    Humanoid.Jump = true
    task.wait(0.05)
    
    RootPart.CFrame = originalCFrame

    if antiGayConn then
        antiGayConn:Disconnect()
        antiGayConn = nil
    end
end

local function BYEBYE()
    if antiGayConn then
        antiGayConn:Disconnect()
        antiGayConn = nil
    end
    
    local PlayerName = LocalPlayer.Name
    local folder = Workspace:FindFirstChild(PlayerName .. "SpawnedInToys")
    if folder then
        local daddy = folder:FindFirstChild("CreatureBlobman")
        if daddy then
            daddy:Destroy()
        end
    end
end

AntiTab:CreateToggle({
    Name = "Gucci Anti-Grab",
    CurrentValue = false,
    Flag = "AntiGucci",
    Callback = function(Value)
        GUCCIISTUFF = Value
        if Value then
            task.spawn(function()
                Gucci()
            end)
        else
            BYEBYE()
        end
    end
})


local AntiSection = AntiTab:CreateSection("Anti-Grab")


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local Struggle = ReplicatedStorage:FindFirstChild("CharacterEvents") and ReplicatedStorage.CharacterEvents:FindFirstChild("Struggle")
local StopAllVelocity = ReplicatedStorage:FindFirstChild("GameCorrectionEvents") and ReplicatedStorage.GameCorrectionEvents:FindFirstChild("StopAllVelocity")

local autoStruggleConn = nil

AntiTab:CreateToggle({
    Name = "Anti-Grab",
    CurrentValue = false,
    Flag = "AntiGrabRayfield",
    Callback = function(Value)
        if Value then
            if autoStruggleConn then
                autoStruggleConn:Disconnect()
            end

            autoStruggleConn = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("Head") then
                    local head = character.Head
                    if head:FindFirstChild("PartOwner") then
                        task.spawn(function()
                            if Struggle then
                                Struggle:FireServer(LocalPlayer)
                            end
                            pcall(function()
                                if StopAllVelocity then
                                    StopAllVelocity:FireServer()
                                end
                            end)
                            for _, part in pairs(character:GetChildren()) do
                                if part:IsA("BasePart") then
                                    part.Anchored = true
                                end
                            end

                            local isHeld = LocalPlayer:FindFirstChild("IsHeld")
                            while isHeld and isHeld.Value do
                                task.wait()
                            end

                            for _, part in pairs(character:GetChildren()) do
                                if part:IsA("BasePart") then
                                    part.Anchored = false
                                end
                            end
                        end)
                    end
                end
            end)
        else
            if autoStruggleConn then
                autoStruggleConn:Disconnect()
                autoStruggleConn = nil
            end
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Anchored = false
                    end
                end
            end
        end
    end
})

local AntiSection = AntiTab:CreateSection("Other-Antis")

local antiExplodeEnabled = false
local antiExplodeConn

AntiTab:CreateToggle({
	Name = "Anti-Explosion",
	CurrentValue = false,
	Flag = "AntiExplosionToggle",
	Callback = function(on)
		antiExplodeEnabled = on

		local Player = game:GetService("Players").LocalPlayer
		local Workspace = game:GetService("Workspace")

		if antiExplodeConn then
			antiExplodeConn:Disconnect()
			antiExplodeConn = nil
		end

		if not on then return end

		local char = Player.Character or Player.CharacterAdded:Wait()
		local hrp = char:WaitForChild("HumanoidRootPart")

		antiExplodeConn = Workspace.ChildAdded:Connect(function(model)
			if not antiExplodeEnabled then return end
			if model.Name ~= "Part" or not model:IsA("BasePart") then return end
			if not hrp or not hrp.Parent then return end

			local mag = (model.Position - hrp.Position).Magnitude
			if mag <= 20 then
				hrp.Anchored = true
				task.wait(0.01)

				local arm = char:FindFirstChild("Right Arm")
				local rag = arm and arm:FindFirstChild("RagdollLimbPart")
				if rag then
					while rag.CanCollide do
						task.wait(0.001)
					end
				end

				hrp.Anchored = false
			end
		end)
	end,
})

local hookBurnConn

function hookBurn(char)
	local hum = char:WaitForChild("Humanoid")
	local hrp = char:WaitForChild("HumanoidRootPart")
	char.PrimaryPart = hrp

	if hookBurnConn then
		hookBurnConn:Disconnect()
		hookBurnConn = nil
	end

	local fireDebounce = hum:WaitForChild("FireDebounce")

	hookBurnConn = fireDebounce.Changed:Connect(function(isBurning)
		if not isBurning then return end

		local oldCF = hrp.CFrame
		local plots = workspace:FindFirstChild("Plots")
		if not plots then return end

		local plot2 = plots:FindFirstChild("Plot2")
		local barrier = plot2 and plot2:FindFirstChild("Barrier")
		local pb = barrier and barrier:FindFirstChild("PlotBarrier")

		if pb and pb:IsA("BasePart") then
			local safeCF = pb.CFrame * CFrame.new(0, 6, 0)
			char:SetPrimaryPartCFrame(safeCF)

			task.wait(0.3)

			local firePart = char:FindFirstChild("FirePlayerPart", true)
			if firePart then
				for _, obj in ipairs(firePart:GetChildren()) do
					if obj:IsA("Sound") then obj:Stop() end
					if obj:IsA("Light") or obj:IsA("ParticleEmitter") then
						obj.Enabled = false
					end
				end

				local cb = firePart:FindFirstChild("CanBurn")
				if cb then cb.Value = false end
				fireDebounce.Value = false
			end

			task.wait(0.6)
			if char and char.PrimaryPart then
				char:SetPrimaryPartCFrame(oldCF)
			end
		end
	end)
end

local AntiFireToggle = AntiTab:CreateToggle({
   Name = "Anti-Fire",
   CurrentValue = false,
   Flag = "AntiFire",
   Callback = function(Value)
      AFE = Value
      task.spawn(function()
         while AFE do
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
               antifirepart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
            end
            antifirepart.CanCollide = not antifirepart.CanCollide
            antifirepart.CanCollide = not antifirepart.CanCollide
            task.wait()
         end
         antifirepart.CFrame = CFrame.new(0,-15,0)
      end)
   end,
})

AK = false

Penis = AntiTab:CreateToggle({
    Name = "Penis Anti-Kick",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
		AK = Value
		while AK do
		    while not game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys"):FindFirstChild("ToolPencil") do
		        if game.Players.LocalPlayer.Character then
    		        if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
    		            game.ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer("ToolPencil",CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position)+Vector3.new(0,0,15),Vector3.new(0,0,0))
    		        end
    		    end
    		    task.wait()
    		end
    		if game.Players.LocalPlayer.Character then
    		    if game.Players.LocalPlayer.Character:FindFirstChild("Torso") and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys"):FindFirstChild("ToolPencil") then
    		        if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil:FindFirstChild("StickyPart") then
    		            if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.StickyPart:FindFirstChild("StickyWeld") then
    		                if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.StickyPart.StickyWeld.Part1 ~= game.Players.LocalPlayer.Character.Torso then
    		                    local a = game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.SoundPart.CFrame.Position
    		                    local b = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position
    		                    local distance = Vector3.new((a.X-b.X)^2,(a.Y-b.Y)^2,(a.Z-b.Z)^2)
    		                    if math.sqrt(distance.X+distance.Y+distance.Z) > 20 then
    		                        game.ReplicatedStorage.MenuToys.DestroyToy:FireServer(game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil)
    		                    else
    		                        game.ReplicatedStorage.PlayerEvents.StickyPartEvent:FireServer(game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.StickyPart,game.Players.LocalPlayer.Character.Torso,CFrame.new(0,-1,0) * CFrame.Angles(0,math.pi,0))
	                    		    for _,prt in pairs(game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil:GetChildren()) do
	                    		        if prt.ClassName == "Part" then
	                    		            prt.CanQuery = false
	                    		        end
                        		    end
                        		    task.wait(0.2)
                        		    if game.Players.LocalPlayer.Character then
                            		    if game.Players.LocalPlayer.Character:FindFirstChild("Torso") and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys"):FindFirstChild("ToolPencil") then
                            		        if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil:FindFirstChild("StickyPart") then
                            		            if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.StickyPart:FindFirstChild("StickyWeld") then
                            		                if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.StickyPart.StickyWeld.Part1 ~= game.Players.LocalPlayer.Character.Torso then
                            		                    if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil then
                            		                        if game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.StickyPart.StickyWeld.Part1 ~= game.Players.LocalPlayer.Character.Torso then
                            		                            game.ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.SoundPart,game.workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys").ToolPencil.SoundPart.CFrame)
                            		                        end
                            		                    end
                            		                end
                            		            end
                            		        end
                            		    end
                            		end
								end
							end
                        end
                    end
                end
	        end
    		task.wait()
        end
    end,
})

local AntiOwnershipKickToggle = AntiTab:CreateToggle({
   Name = "Anti Ownership-Kick",
   CurrentValue = false,
   Flag = "AntiOwnershipKick",
   Callback = function(Value)
      antiok = Value
      task.spawn(function()
         while antiok do
            if game.Players.LocalPlayer.Character then
               if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                  if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame.Position.Magnitude > 10000000 then
                     game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(0,-10,0)
                     game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").AssemblyLinearVelocity = Vector3.new(0,0,0)
                  end
               end
            end
            task.wait()
         end
      end)
   end,
})


local AntiLagToggle = AntiTab:CreateToggle({
   Name = "Anti-Lag",
   CurrentValue = false,
   Flag = "AntiLag",
   Callback = function(Value)
      ALAGE = Value
      if Value then 
         game:GetService("Players").LocalPlayer.PlayerScripts.CharacterAndBeamMove.Disabled = true
         for _,plr in pairs(game:GetService("Players"):GetChildren()) do
            if plr.Character:FindFirstChild("GrabParts") then
               plr.Character.GrabParts:Destroy()
            end
         end
         Rayfield:Notify({
            Title = "Anti-Lag Enabled",
            Content = "Performance improved",
            Duration = 2,
            Image = 4483345998,
         })
      else
         game:GetService("Players").LocalPlayer.PlayerScripts.CharacterAndBeamMove.Enabled = true
         Rayfield:Notify({
            Title = "Anti-Lag Disabled",
            Content = "Normal performance restored",
            Duration = 2,
            Image = 4483345998,
         })
      end
   end,
})

AntiTab:CreateToggle({
    Name = "Anti Input Lag",
    CurrentValue = false,
    Flag = "AntiInputLag",
    Callback = function(Value)
        _G.AntiInputLag = Value
        if Value then
            task.spawn(function()
                local SpawnRemote = ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")
                while _G.AntiInputLag do
                    local char = LocalPlayer.Character
                    local hrp = char and char:WaitForChild("HumanoidRootPart")
                    if not hrp then
                        task.wait(0.1)
                        continue
                    end
                    
                    local toysFolder = Workspace:FindFirstChild(LocalPlayer.Name .. "SpawnedInToys")
                    if not toysFolder then
                        task.wait(0.1)
                        continue
                    end
                    
                    local toy = toysFolder:FindFirstChild(SelectedToy)
                    if not toy then
                        pcall(function()
                            SpawnRemote:InvokeServer(SelectedToy, hrp.CFrame * CFrame.new(0, 5, 0), Vector3.zero)
                        end)
                        local t0 = tick()
                        repeat
                            RunService.Heartbeat:Wait()
                            toysFolder = Workspace:FindFirstChild(LocalPlayer.Name .. "SpawnedInToys")
                            toy = toysFolder and toysFolder:FindFirstChild(SelectedToy)
                        until toy or tick() - t0 > 1 or not _G.AntiInputLag
                    end
                    
                    if toy and toy.Parent then
                        local holdPart = toy:FindFirstChild("HoldPart")
                        if holdPart then
                            local holdingPlayer = holdPart:FindFirstChild("HoldingPlayer")
                            holdingPlayer = holdingPlayer and holdingPlayer.Value
                            if holdingPlayer and holdingPlayer ~= LocalPlayer then
                                pcall(function()
                                    holdPart.DropItemRemoteFunction:InvokeServer(toy, hrp.CFrame * CFrame.new(0, 2000, 0), Vector3.zero)
                                end)
                                toy:Destroy()
                            else
                                pcall(function()
                                    holdPart.HoldItemRemoteFunction:InvokeServer(toy, char)
                                end)
                                task.wait(0.05)
                                pcall(function()
                                    holdPart.DropItemRemoteFunction:InvokeServer(toy, hrp.CFrame * CFrame.new(0, 2000, 0), Vector3.zero)
                                end)
                                task.wait(0.01)
                            end
                        end
                    end
                    RunService.Heartbeat:Wait()
                end
            end)
        end
    end,
})

AntiKickToggle = AntiTab:CreateToggle({
    Name = "Anti Kick Best One",
    CurrentValue = false,
    Flag = "AntiKickToggle",
    Callback = function(Value)
        getgenv().AntiKickEnabled = Value
        
        if Value then
            task.spawn(function()
                local plr = game.Players.LocalPlayer
                local inv = workspace[plr.Name.."SpawnedInToys"]
                local hrp

                local setOwner = game.ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
                local stickyEvent = game.ReplicatedStorage:WaitForChild("PlayerEvents"):WaitForChild("StickyPartEvent")
                local destroyrem = game.ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("DestroyToy")
                local canSpawn = plr:WaitForChild("CanSpawnToy")

                local function getHRP()
                    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                        return plr.Character.HumanoidRootPart
                    else
                        local character = plr.CharacterAdded:Wait()
                        return character:WaitForChild("HumanoidRootPart")
                    end
                end

                local function CheckForHome()
                    local ToyFolder
                    if not workspace.PlotItems.PlayersInPlots:FindFirstChild(plr.Name) then 
                        return false
                    end
                    for _, v in pairs(workspace.Plots:GetChildren()) do
                        for _, b in pairs(v.PlotSign.ThisPlotsOwners:GetChildren()) do
                            if b.Value == plr.Name then
                                ToyFolder = workspace.PlotItems[v.Name]
                            end
                        end
                    end
                    if ToyFolder then 
                        return true, ToyFolder
                    else 
                        return false
                    end
                end

                local function StickKunai(kunai)
                    if not kunai or not kunai:FindFirstChild("StickyPart") then return end

                    local currentHRP = getHRP()
                    
                    if kunai:FindFirstChild("SoundPart") then
                        if not kunai["SoundPart"]:FindFirstChild("PartOwner") or kunai["SoundPart"].PartOwner.Value ~= plr.Name then 
                            setOwner:FireServer(kunai.SoundPart, kunai.SoundPart.CFrame)
                        end
                    end
                    
                    stickyEvent:FireServer(
                        kunai.StickyPart,
                        currentHRP:FindFirstChild("FirePlayerPart") or currentHRP:WaitForChild("FirePlayerPart"),
                        CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(90),math.rad(90))
                    )
                    
                    for _, obj in pairs(kunai:GetChildren()) do
                        if obj.Name == "Pyramid" then
                            obj.CanTouch = false
                            obj.CanCollide = false
                            obj.CanQuery = false
                            obj.Transparency = 0
                            local high = Instance.new("Highlight")
                            high.FillColor = Color3.fromRGB(0, 0, 0)
                            high.Parent = obj

                        elseif obj.Name == "Main" then
                            obj.CanTouch = false
                            obj.CanCollide = false
                            obj.CanQuery = false
                            obj.Transparency = 0
                            local high = Instance.new("Highlight")
                            high.FillColor = Color3.fromRGB(255, 255, 255)
                            high.Parent = obj

                        elseif obj:IsA("BasePart") then
                            obj.CanTouch = false
                            obj.CanCollide = false
                            obj.CanQuery = false
                            obj.Transparency = 1
                        end
                    end
                end

                local function ClearKunai()
                    for _,v in pairs(inv:GetChildren()) do
                        if v.Name == "AntiKick" then
                            destroyrem:FireServer(v)
                        end
                    end
                end

                local function SpawnToy(name)
                    while not canSpawn.Value do
                        canSpawn.Changed:Wait()
                    end

                    local currentHRP = getHRP()
                    
                    task.spawn(function()
                        game.ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(
                            name,
                            currentHRP.CFrame * CFrame.new(0, 12, 20),
                            Vector3.new(0,0,0)
                        )
                    end)
                    
                    local boolik, house = CheckForHome()
                    if boolik then 
                        return house:WaitForChild(name, 2)
                    elseif not workspace.PlotItems.PlayersInPlots:FindFirstChild(plr.Name) then 
                        return inv:WaitForChild(name, 2)
                    elseif workspace.PlotItems.PlayersInPlots:FindFirstChild(plr.Name) and not boolik then 
                        return nil
                    end
                end

                while getgenv().AntiKickEnabled do 
                    task.wait(0.005)

                    if not plr.Character or not plr.Character:FindFirstChild("Humanoid") or plr.Character.Humanoid.Health <= 0 then 
                        continue 
                    end
                    
                    local kunai = inv:FindFirstChild("NinjaShuriken")
                    
                    if workspace.PlotItems.PlayersInPlots:FindFirstChild(plr.Name) then 
                        local boolik, house = CheckForHome()
                        if boolik and house and workspace.Plots:FindFirstChild(house.Name) and workspace.Plots:FindFirstChild(house.Name)["PlotSign"]["ThisPlotsOwners"]:FindFirstChild("Value") and workspace.Plots:FindFirstChild(house.Name)["PlotSign"]["ThisPlotsOwners"]["Value"]["TimeRemainingNum"].Value > 89 then 
                            kunai = SpawnToy("NinjaShuriken")
                            if kunai == nil then continue end
                            kunai.Name = "AntiKick" 
                            StickKunai(kunai)
                        end
                    end
                    
                    if not kunai then
                        if workspace.PlotItems.PlayersInPlots:FindFirstChild(plr.Name) then continue end 
                        kunai = SpawnToy("NinjaShuriken")
                        if kunai == nil then continue end 
                        kunai.Name = "AntiKick"
                        if not kunai then continue end 
                    end
                    
                    repeat
                        if kunai and kunai:FindFirstChild("StickyPart") and kunai.StickyPart.CanTouch == true then
                            StickKunai(kunai)
                            kunai.Name = "AntiKick"
                        end
                        wait(0.3)
                    until not kunai or not getgenv().AntiKickEnabled 
                        or not kunai:FindFirstChild("StickyPart")
                        or kunai.StickyPart.CanTouch == false 
                        or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") 
                        or not kunai:FindFirstChild("StickyPart") 
                        or (plr.Character.HumanoidRootPart.Position - kunai.StickyPart.Position).Magnitude >= 20

                    if not kunai or not kunai:FindFirstChild("StickyPart") or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or (plr.Character.HumanoidRootPart.Position - kunai.StickyPart.Position).Magnitude >= 20 then 
                        ClearKunai()
                    end 
                    
                    pcall(function()
                        repeat
                            wait(0.05)
                        until not getgenv().AntiKickEnabled or not plr.Character or not plr.Character:FindFirstChild("Humanoid") or not kunai or not kunai:FindFirstChild("StickyPart") or not kunai.StickyPart:FindFirstChild("StickyWeld") or not kunai.StickyPart.StickyWeld.Part1
                        
                        if not kunai or not kunai:FindFirstChild("StickyPart") or (plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health <= 0) or not kunai["StickyPart"]:FindFirstChild("StickyWeld").Part1 then 
                            ClearKunai()
                        end
                    end)
                end
            end)
        end
    end,
})

local AntiblobToggle = AntiTab:CreateToggle({
   Name = "Anti-Blob",
   CurrentValue = false,
   Flag = "Antiblob",
   Callback = function(Value)
      antiblob = Value
      task.spawn(function()
         while antiblob do
            if game.Players.LocalPlayer.Character then
               if not game.Players.LocalPlayer.Character:FindFirstChild("TruePositionPart") then
                  local tp = Instance.new("Part")
                  tp.Parent = game.Players.LocalPlayer.Character
                  tp.Name = "TruePositionPart"
                  tp.Anchored = true
                  tp.CFrame = CFrame.new(0,-100,0)
               end
               for _,prt in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
                  if prt:IsA("BasePart") then
                     if prt.Massless then
                        prt.Massless = false
                     end
                  end
                  if prt.Name == "HumanoidRootPart" then
                     if game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("RootAttachment") then
                        task.wait(0.5)
                        task.wait()
                        if game.Players.LocalPlayer.Character then
                           if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("RootAttachment") and game.Players.LocalPlayer.Character:FindFirstChild("TruePositionPart") then
                              game.Players.LocalPlayer.Character.HumanoidRootPart.RootAttachment.Parent = game.Players.LocalPlayer.Character.TruePositionPart
                              Rayfield:Notify({
                                 Title = "Antiblob Enabled",
                                 Content = "Protection active",
                                 Duration = 2,
                                 Image = 4483345998,
                              })
                           end
                        end
                     end
                  end
               end
            end
            task.wait()
         end
      end)
      
      if not Value and game.Players.LocalPlayer.Character then
         if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character:FindFirstChild("TruePositionPart") then
            if game.Players.LocalPlayer.Character.TruePositionPart:FindFirstChild("RootAttachment") then
               game.Players.LocalPlayer.Character.TruePositionPart.RootAttachment.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
               Rayfield:Notify({
                  Title = "Antiblob Disabled",
                  Content = "Protection disabled",
                  Duration = 2,
                  Image = 4483345998,
               })
            end
         end
      end
   end,
})

local DisableVoidToggle = AntiTab:CreateToggle({
   Name = "Disable-Void",
   CurrentValue = false,
   Flag = "DisableVoid",
   Callback = function(Value)
      antiboid = Value
      if Value then 
         workspace.FallenPartsDestroyHeight = 0/0
         Rayfield:Notify({
            Title = "Void Disabled",
            Content = "Fall protection active",
            Duration = 2,
            Image = 4483345998,
         })
      else
         workspace.FallenPartsDestroyHeight = -100
         Rayfield:Notify({
            Title = "Void Enabled",
            Content = "Fall protection disabled",
            Duration = 2,
            Image = 4483345998,
         })
      end
   end,
})

local LoopTab = Window:CreateTab("Target", "crosshair")

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
Workspace = game:GetService("Workspace")
RunService = game:GetService("RunService")
LocalPlayer = Players.LocalPlayer

GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
RemoteSetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")
RemoteDestroyGrabLine = GrabEvents:WaitForChild("DestroyGrabLine")
SpawnToyRF = ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")

SelectedPlayer = nil
KillHB, KickHB, GrabKickHB = nil, nil, nil
LoopKickOn, LoopKillOn, LoopBlobKickOn, LoopBlobKillOn, LoopGrabKickOn = false, false, false, false, false
spamActive = false

HEIGHT_LIMIT = 100000
TELEPORT_OFFSET = Vector3.new(6, -18.5, 0)

function sno(part)
    if not part or not part.Parent then return end
    pcall(function()
        RemoteSetNetworkOwner:FireServer(part, part.CFrame)
    end)
end

function DisableCollisions(model)
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then d.CanCollide = false end
    end
end

function setNoCollideChar(char)
    for _, v in ipairs(char:GetDescendants()) do
        if v:IsA("BasePart") then v.CanCollide = false end
    end
end

function isTooHigh(plr)
    local c = plr.Character
    local hrp = c and c:FindFirstChild("HumanoidRootPart")
    return not hrp or hrp.Position.Y > HEIGHT_LIMIT
end

function findBlobman()
    local toys = Workspace:FindFirstChild(LocalPlayer.Name .. "SpawnedInToys")
    return toys and toys:FindFirstChild("CreatureBlobman") or nil
end

function spawnBlobman()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    SpawnToyRF:InvokeServer("CreatureBlobman", char.HumanoidRootPart.CFrame * CFrame.new(0, 0, -5), Vector3.new(0, -15, 0))
end

function ensureBlobman()
    local b = findBlobman()
    if b then return b end
    spawnBlobman()
    for _ = 1, 30 do
        task.wait(0.1)
        b = findBlobman()
        if b then return b end
    end
    return nil
end

CameraAnchor = {}
CameraAnchor.__index = CameraAnchor
function CameraAnchor.new() return setmetatable({}, CameraAnchor) end
function CameraAnchor:attach(cf)
    self:detach()
    local p = Instance.new("Part")
    p.Name, p.Size, p.Transparency, p.Anchored, p.CanCollide, p.CFrame, p.Parent =
        "CameraAnchor", Vector3.new(0.2, 0.2, 0.2), 1, true, false, cf, Workspace
    self.part = p
    local cam = Workspace.CurrentCamera
    cam.CameraType = Enum.CameraType.Custom
    cam.CameraSubject = p
end
function CameraAnchor:detach()
    if self.part then self.part:Destroy() self.part = nil end
    local cam = Workspace.CurrentCamera
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        cam.CameraSubject = char.Humanoid
    else
        cam.CameraType = Enum.CameraType.Custom
        cam.CameraSubject = cam
    end
end
local cameraAnchor = CameraAnchor.new()

function saveOriginalPosAttr()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
        char:SetAttribute("OriginalPosition", hrp:GetPivot())
    end
end

function getOriginalPosAttr()
    local char = LocalPlayer.Character
    return char and char:GetAttribute("OriginalPosition") or nil
end

function initCharAttrs()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char:SetAttribute("OriginalPosition", char.HumanoidRootPart:GetPivot())
        char:SetAttribute("SavingOriginalPos", false)
    end
end

function scheduleReturnHome()
    local originalPos = getOriginalPosAttr()
    if not originalPos then return end
    
    local conn
    conn = RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp:PivotTo(originalPos)
            if getgenv().originalFallenHeight then
                Workspace.FallenPartsDestroyHeight = getgenv().originalFallenHeight
            end
            char:SetAttribute("SavingOriginalPos", false)
        end
        cameraAnchor:detach()
        conn:Disconnect()
    end)
end

function modifyTarget(root, hum)
    if not (root and hum) or hum.Health <= 0 then return end
    local blob = ensureBlobman()
    if blob and blob:FindFirstChild("BlobmanSeatAndOwnerScript") then
        local drop = blob.BlobmanSeatAndOwnerScript:FindFirstChild("CreatureDrop")
        if drop then
            for _, part in ipairs(hum.Parent:GetDescendants()) do
                if part:IsA("Weld") or part:IsA("BallSocketConstraint") then
                    drop:FireServer(part, part)
                end
            end
        end
    end
    hum.Sit = false
    hum:ChangeState(Enum.HumanoidStateType.Running)
    hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    hum:ChangeState(Enum.HumanoidStateType.GettingUp)

    local plr = Players:GetPlayerFromCharacter(hum.Parent)
    if plr and plr:FindFirstChild("IsHeld") then plr.IsHeld.Value = false end
    local rag = hum:FindFirstChild("Ragdolled")
    if rag then rag.Value = false end

    local bv, bav = Instance.new("BodyVelocity"), Instance.new("BodyAngularVelocity")
    bv.MaxForce = Vector3.new(1e7, -1e7, 1e7)
    bv.P = 100
    bv.Velocity = Vector3.new(math.random(-500, 50), -50, math.random(-50, 50))
    bav.MaxTorque = Vector3.new(-1e7, -1e7, -1e7)
    bav.P = 1e6
    bav.AngularVelocity = Vector3.new(math.random(-500, 300), math.random(-300, 300), math.random(-500, 500))
    bv.Parent, bav.Parent = root, root

    hum.BreakJointsOnDeath = false
    hum:ChangeState(Enum.HumanoidStateType.Dead)
    hum.RigType = Enum.HumanoidRigType.R15

    task.delay(1.5, function()
        if bv.Parent then bv:Destroy() end
        if bav.Parent then bav:Destroy() end
    end)
end

function performKill()
    if not SelectedPlayer then return end
    
    local target = Players:FindFirstChild(SelectedPlayer)
    local tChar = target and target.Character
    local tRoot = tChar and tChar:FindFirstChild("HumanoidRootPart")
    local tHum = tChar and tChar:FindFirstChild("Humanoid")
    local tHead = tChar and tChar:FindFirstChild("Head")
    
    if not (target and tRoot and tHum and tHead) then return end
    if isTooHigh(target) then return end
    if target:FindFirstChild("InPlot") and target.InPlot.Value then return end
    if tHum:GetState() == Enum.HumanoidStateType.Dead then return end

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not (char and hrp) then return end

    if not char:GetAttribute("SavingOriginalPos") then
        saveOriginalPosAttr()
    end
    char:SetAttribute("SavingOriginalPos", true)

    getgenv().originalFallenHeight = Workspace.FallenPartsDestroyHeight
    Workspace.FallenPartsDestroyHeight = 0/0

    local originalPos = getOriginalPosAttr()
    if originalPos then
        cameraAnchor:attach(originalPos)
    end

    local desiredCFrame = CFrame.new(tRoot.Position + TELEPORT_OFFSET)
    hrp:PivotTo(desiredCFrame)

    setNoCollideChar(tChar)
    RemoteSetNetworkOwner:FireServer(tRoot, tRoot.CFrame)
    task.wait()
    RemoteDestroyGrabLine:FireServer(tRoot)
    task.wait()

    if tHead:FindFirstChild("PartOwner") and tHead.PartOwner.Value == LocalPlayer.Name then
        task.wait()
        modifyTarget(tRoot, tHum)
    end

    scheduleReturnHome()
end

function StartLoopKill()
    if KillHB then KillHB:Disconnect() end
    KillHB = RunService.Heartbeat:Connect(performKill)
end

function StopLoopKill()
    if KillHB then KillHB:Disconnect() KillHB = nil end
    cameraAnchor:detach()
end

function sendToSky(root, hum)
    DisableCollisions(hum.Parent)
    local BV = Instance.new("BodyVelocity")
    BV.Velocity = Vector3.new(0, 9000000, 0)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    BV.P = 100
    BV.Parent = root
    hum.Sit = false
    hum.Jump = true
    task.delay(0, function() if BV.Parent then BV:Destroy() end end)
end

function getPlayerList()
    local list = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local displayName = plr.DisplayName or plr.Name
            local entry = string.format("%s (@%s)", displayName, plr.Name)
            table.insert(list, entry)
        end
    end
    return list
end

function extractUsername(entry)
    local username = entry:match("@([%w_]+)")
    return username
end

PlayerDropdown = LoopTab:CreateDropdown({
    Name = "Select Player",
    Options = getPlayerList(),
    CurrentOption = {},
    Flag = "PlayerDropdown",
    Callback = function(option)
        local selected = type(option) == "table" and option[1] or option
        SelectedPlayer = extractUsername(selected)
    end
})

LoopTab:CreateButton({
    Name = "Refresh Player List",
    Callback = function()
        PlayerDropdown:Refresh(getPlayerList(), true)
    end
})

local LoopSection = LoopTab:CreateSection(" Loops ")

LoopTab:CreateToggle({
    Name = "Loop-Kill",
    CurrentValue = false,
    Flag = "LoopKillToggle",
    Callback = function(v) 
        if v then StartLoopKill() else StopLoopKill() end 
    end
})

LoopTab:CreateToggle({
    Name = 'Loop-Grab-Kick',
    CurrentValue = false,
    Flag = "LoopGrabKickToggle",
    Callback = function(Value)
        LoopGrabKickOn = Value
        
        if LoopGrabKickOn then
            if not SelectedPlayer or SelectedPlayer == "" then
                LoopGrabKickOn = false
                return
            end
            
            task.spawn(function()
                local targetplr = Players:FindFirstChild(SelectedPlayer)
                if not targetplr then 
                    LoopGrabKickOn = false
                    return 
                end
                
                while LoopGrabKickOn do
                    local char = LocalPlayer.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    local head = char and char:FindFirstChild("Head")
                    
                    if not (char and hrp and head) then 
                        task.wait()
                        continue 
                    end

                    targetplr = Players:FindFirstChild(SelectedPlayer)
                    if not targetplr or not targetplr.Character then 
                        task.wait()
                        continue 
                    end
                    
                    local targetChar = targetplr.Character
                    local targetHrp = targetChar:FindFirstChild("HumanoidRootPart")
                    local targetHead = targetChar:FindFirstChild("Head")
                    local Hum = targetChar:FindFirstChild("Humanoid")
                    
                    if not (targetHrp and targetHead and Hum) or Hum.Health == 0 then 
                        task.wait()
                        continue 
                    end

                    local BodyPos = targetHrp:FindFirstChild("BodyPosition")
                    local BodyGyro = targetHrp:FindFirstChild("BodyGyro")
                    
                    if not BodyPos then
                        BodyPos = Instance.new("BodyPosition")
                        BodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                        BodyPos.Parent = targetHrp
                        BodyPos.P = 50000
                        BodyPos.D = 1000
                    end
                    
                    if not BodyGyro then
                        BodyGyro = Instance.new("BodyGyro")
                        BodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                        BodyGyro.Parent = targetHrp
                        BodyGyro.P = 50000
                        BodyGyro.D = 1000
                    end
                    
                    BodyPos.Position = head.Position + Vector3.new(0, 18, 0)
                    BodyGyro.CFrame = hrp.CFrame
                    
                    for i = 1, 2 do
                        sno(targetHrp)
                        sno(targetHead)
                    end
                    
                    RemoteDestroyGrabLine:FireServer(targetHrp)
                    RemoteDestroyGrabLine:FireServer(targetHead)

                    if (targetHrp.Position - hrp.Position).Magnitude > 35 then
                        local oldCF = char:GetPivot()
                        
                        repeat
                            if not LoopGrabKickOn then break end
                            
                            char:PivotTo(targetHrp.CFrame * CFrame.new(0, 0, -10))
                            
                            for i = 1, 2 do
                                sno(targetHrp)
                                sno(targetHead)
                            end
                            
                            task.wait()
                        until (targetHrp.Position - hrp.Position).Magnitude <= 35
                            or targetHead:FindFirstChild("PartOwner")
                            or not LoopGrabKickOn
                        
                        char:PivotTo(oldCF)

                        if targetHead:FindFirstChild("PartOwner") then
                            for i = 1, 2 do
                                if not LoopGrabKickOn or not targetHrp.Parent then break end
                                targetHrp.CFrame = CFrame.new(head.Position + Vector3.new(0, 20, 0))
                                sno(targetHrp)
                                sno(targetHead)
                                task.wait()
                            end
                        end
                    end
                    
                    task.wait()
                end
    
                if targetplr and targetplr.Character then
                    local targetHrp = targetplr.Character:FindFirstChild("HumanoidRootPart")
                    if targetHrp then
                        if targetHrp:FindFirstChild("BodyPosition") then
                            targetHrp.BodyPosition:Destroy()
                        end
                        if targetHrp:FindFirstChild("BodyGyro") then
                            targetHrp.BodyGyro:Destroy()
                        end
                    end
                end
            end)
        end
    end
}) 

local LoopSection = LoopTab:CreateSection(" Blob-Man Loop")

LoopTab:CreateToggle({
    Name = 'Spam-kick [SPAWN BLOBMAN FIRST]',
    CurrentValue = false,
    Flag = "spamkicktoggle",
    Callback = function(Value)
        spamActive = Value
        if not Value then
            return
        end

        -- sanity checks
        if not SelectedPlayer then
            spamActive = false
            return
        end

        local blob = findBlobman()
        if not blob then
            spamActive = false
            return
        end

        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            spamActive = false
            return
        end

        local RightDetector = blob:FindFirstChild("RightDetector")
        if not RightDetector then
            spamActive = false
            return
        end

        local RightWeld = RightDetector:FindFirstChild("RightWeld")
        local BlobmanScript = blob:FindFirstChild("BlobmanSeatAndOwnerScript")
        if not (RightWeld and BlobmanScript) then
            spamActive = false
            return
        end

        local CreatureGrab = BlobmanScript:FindFirstChild("CreatureGrab")
        local CreatureRelease = BlobmanScript:FindFirstChild("CreatureRelease")
        if not (CreatureGrab and CreatureRelease) then
            spamActive = false
            return
        end

        task.spawn(function()
            local oldCF = char:GetPivot()

            local targetPlayer = Players:FindFirstChild(SelectedPlayer)
            local targetChar = targetPlayer and targetPlayer.Character
            if not targetChar or not targetChar:FindFirstChild("HumanoidRootPart") then
                spamActive = false
                return
            end

            local targetRoot = targetChar.HumanoidRootPart

            -- initial grab
            pcall(function()
                char:PivotTo(targetRoot.CFrame)
                task.wait(0.3)

                CreatureGrab:FireServer(RightDetector, targetRoot, RightWeld)
                task.wait(0.2)

                CreatureRelease:FireServer(RightWeld, targetRoot)

                task.defer(function()
                    local BodyPos = Instance.new("BodyPosition")
                    BodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    BodyPos.Position =
                        oldCF.Position
                        + Vector3.new(
                            math.random(-15, 15),
                            math.random(-10, 10),
                            math.random(-15, 15)
                        )
                    BodyPos.P = 45000
                    BodyPos.D = 500
                    BodyPos.Parent = targetRoot
                end)
            end)

            task.wait(0.3)
            pcall(function()
                char:PivotTo(oldCF)
            end)
            task.wait(0.3)

            while spamActive do
                targetPlayer = Players:FindFirstChild(SelectedPlayer)
                if not targetPlayer then
                    spamActive = false
                    break
                end

                targetChar = targetPlayer.Character
                if not targetChar or not targetChar:FindFirstChild("HumanoidRootPart") then
                    task.wait()
                    continue
                end

                targetRoot = targetChar.HumanoidRootPart
                local targetHead = targetChar:FindFirstChild("Head")

                pcall(function()
                    sno(targetRoot)
                    if targetHead then
                        sno(targetHead)
                    end

                    RemoteDestroyGrabLine:FireServer(targetRoot)

                    CreatureGrab:FireServer(RightDetector, targetRoot, RightWeld)

                    if targetHead then
                        GrabEvents.CreateGrabLine:FireServer(targetHead, targetHead.CFrame)
                    end
                    GrabEvents.CreateGrabLine:FireServer(targetRoot, targetRoot.CFrame)

                    CreatureRelease:FireServer(RightWeld, targetRoot)
                end)

                task.wait()
            end
        end)
    end
})

LoopTab:CreateToggle({
    Name = "Blobman-Kick",
    CurrentValue = false,
    Flag = "blobkicktoggle",
    Callback = function(enabled)
        LoopBlobKickOn = enabled

        local respawnConn

        function findMountedBlob()
            local char = Players.LocalPlayer.Character
            local hum = char and char:FindFirstChild("Humanoid")
            local seat = hum and hum.SeatPart
            return (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") and seat.Parent or nil
        end

        function bringRightArm(targetName, blob)
            if not LoopBlobKickOn or not blob then return end

            local tp = Players:FindFirstChild(targetName)
            local char = tp and tp.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local rd = blob:FindFirstChild("RightDetector")
            local weld = rd and rd:FindFirstChild("RightWeld")
            local script = blob:FindFirstChild("BlobmanSeatAndOwnerScript")
            local grab = script and script:FindFirstChild("CreatureGrab")

            if hrp and grab and weld then
                grab:FireServer(Players.LocalPlayer, hrp, weld)
            end
        end

        function execBlobKick(targetName)
            if not LoopBlobKickOn then return end

            local char = Players.LocalPlayer.Character
            local hum = char and char:FindFirstChild("Humanoid")
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not (hum and hrp) then return end

            local blob = findMountedBlob() or ensureBlobman()
            if not blob or not LoopBlobKickOn then return end

            task.wait(0.1)

            local seat = blob:FindFirstChild("VehicleSeat")
            if seat and hum.SeatPart ~= seat then
                seat:Sit(hum)
                task.wait(0.1)
            end

            if not LoopBlobKickOn then return end

            local tp = Players:FindFirstChild(targetName)
            local tChar = tp and tp.Character
            local tHRP = tChar and tChar:FindFirstChild("HumanoidRootPart")
            if not tHRP then return end

            local startSelf = hrp.CFrame
            local startBlob = blob.PrimaryPart and blob.PrimaryPart.CFrame
            local oldCF = tHRP.CFrame

            hrp.CFrame = oldCF
            task.wait(0.1)

            for _ = 1, 15 do
                if not LoopBlobKickOn then return end
                RemoteSetNetworkOwner:FireServer(tHRP, tHRP.CFrame)
                tHRP.CFrame = oldCF * CFrame.new(0, 40, 0)
                task.wait()
            end

            RemoteDestroyGrabLine:FireServer(tHRP)
            task.wait(0.1)

            bringRightArm(targetName, blob)
            bringRightArm(targetName, blob)
            bringRightArm(targetName, blob)

            task.delay(0.8, function()
                if not LoopBlobKickOn then return end
                if hrp then hrp.CFrame = startSelf end
                if blob and blob.PrimaryPart and startBlob then
                    blob:SetPrimaryPartCFrame(startBlob)
                end
            end)
        end

        function monitorRespawnBlobKick(targetName)
            local tp = Players:FindFirstChild(targetName)
            if not tp then return end

            if respawnConn then respawnConn:Disconnect() end
            respawnConn = tp.CharacterAdded:Connect(function()
                if LoopBlobKickOn then
                    task.wait(1)
                    execBlobKick(targetName)
                end
            end)
        end

        if enabled then
            if SelectedPlayer and SelectedPlayer ~= "" then
                execBlobKick(SelectedPlayer)
                monitorRespawnBlobKick(SelectedPlayer)
            end
        else
            LoopBlobKickOn = false
            if respawnConn then
                respawnConn:Disconnect()
                respawnConn = nil
            end
        end
    end
})



LoopTab:CreateToggle({
    Name = "Blob-Kill",
    CurrentValue = false,
    Flag = "BlobKillToggle",
    Callback = function(enabled)
        LoopBlobKillOn = enabled

        local function execBlobKill(targetName)
            if not targetName or targetName == "" then return end
            local plr = Players:FindFirstChild(targetName)
            if not plr or not plr.Character then return end
            local localPlayer = Players.LocalPlayer
            local localChar = localPlayer.Character
            if not localChar then return end
            local hum = localChar:FindFirstChild("Humanoid")
            local hrp = localChar:FindFirstChild("HumanoidRootPart")
            if not (hum and hrp) then return end
            local blob =
            (hum.SeatPart
                and hum.SeatPart.Parent.Name == "CreatureBlobman"
                and hum.SeatPart.Parent)
            or ensureBlobman()
            
            if not blob or not blob.PrimaryPart then
    return
end

local targetHRP = plr.Character:FindFirstChild("HumanoidRootPart")
if not targetHRP then
    return
end
if targetHRP.Position.Y > HEIGHT_LIMIT then return end

        local startLocalCFrame = hrp.CFrame
        local startBlobCFrame = blob.PrimaryPart.CFrame

        blob:SetPrimaryPartCFrame(targetHRP.CFrame)

        if blob:FindFirstChild("VehicleSeat") then
            blob.VehicleSeat:Sit(hum)
            task.wait(0.05)
        end

        local detector = blob:FindFirstChild("LeftDetector")
        local weld = detector and detector:FindFirstChild("LeftWeld")
        if detector and weld then
            blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(detector, targetHRP, weld)
        end

        task.wait(0.05)

        local targetHum = plr.Character:FindFirstChildOfClass("Humanoid")
        if targetHum then
            targetHum.RigType = Enum.HumanoidRigType.R15
        end

        task.wait(0.05)

        if weld then
            blob.BlobmanSeatAndOwnerScript.CreatureRelease:FireServer(weld, targetHRP)
        end

        task.delay(0.05, function()
            hrp.CFrame = startLocalCFrame
            if blob and blob.PrimaryPart then
                blob:SetPrimaryPartCFrame(startBlobCFrame)
            end
        end)
    end

    if enabled then
        task.spawn(function()
            while LoopBlobKillOn do
                if SelectedPlayer and Players:FindFirstChild(SelectedPlayer) then
                    local plr = Players[SelectedPlayer]
                    local hum = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
                    if hum and hum.Health > 0 then
                        execBlobKill(SelectedPlayer)
                    end
                end
                task.wait(0.06)
            end
        end)
    else
        LoopBlobKillOn = false
    end
end
})

LoopTab:CreateToggle({
Name = 'Spam-Kick (Blob)',
CurrentValue = false,
Flag = "SpamKickToggle",
Callback = function(Value)
spamActive = Value if Value then
        if not SelectedPlayer then
            spamActive = false
            return
        end
        
        local blob = findBlobman()
        if not blob then
            spamActive = false
            return
        end
        
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            spamActive = false
            return
        end
        
        local RightDetector = blob:FindFirstChild("RightDetector")
        if not RightDetector then
            spamActive = false
            return
        end
        
        local RightWeld = RightDetector:FindFirstChild("RightWeld")
        local BlobmanScript = blob:FindFirstChild("BlobmanSeatAndOwnerScript")
        
        if not (RightWeld and BlobmanScript) then
            spamActive = false
            return
        end
        
        local CreatureGrab = BlobmanScript:FindFirstChild("CreatureGrab")
        local CreatureRelease = BlobmanScript:FindFirstChild("CreatureRelease")
        
        if not (CreatureGrab and CreatureRelease) then
            spamActive = false
            return
        end
        
        task.spawn(function()
            local oldCF = char:GetPivot()
            local targetPlayer = Players:FindFirstChild(SelectedPlayer)
            local targetChar = targetPlayer and targetPlayer.Character
            
            if not targetChar or not targetChar:FindFirstChild("HumanoidRootPart") then
                spamActive = false
                return
            end
            
            local targetRoot = targetChar.HumanoidRootPart
            
            pcall(function()
                char:PivotTo(targetRoot.CFrame)
                task.wait(0.18)
                CreatureGrab:FireServer(RightDetector, targetRoot, RightWeld)
                task.wait(0.18)
                CreatureRelease:FireServer(RightWeld, targetRoot)
                
                task.defer(function()
                    local BodyPos = Instance.new("BodyPosition")
                    BodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    BodyPos.Position = oldCF.Position + Vector3.new(math.random(-15, 15), math.random(-10, 10), math.random(-15, 15))
                    BodyPos.Parent = targetRoot
                    BodyPos.P = 45000
                    BodyPos.D = 500
                end)
            end)
            
            task.wait(0.18)
            pcall(function()
                char:PivotTo(oldCF)
            end)
            task.wait(0.18)
            
            while spamActive do
                targetPlayer = Players:FindFirstChild(SelectedPlayer)
                if not targetPlayer or not Players:FindFirstChild(SelectedPlayer) then
                    spamActive = false
                    break
                end
                
                if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    task.wait(0.18)
                    continue
                end
                
                targetRoot = targetPlayer.Character.HumanoidRootPart
                local targetHead = targetPlayer.Character:FindFirstChild("Head")
                
                pcall(function()
                    sno(targetRoot)
                    if targetHead then
                        sno(targetHead)
                    end
                    RemoteDestroyGrabLine:FireServer(targetRoot)
                    
                    CreatureGrab:FireServer(RightDetector, targetRoot, RightWeld)
                    
                    if targetHead then
                        GrabEvents.CreateGrabLine:FireServer(targetHead, targetHead.CFrame)
                    end
                    GrabEvents.CreateGrabLine:FireServer(targetRoot, targetRoot.CFrame)
                    
                    CreatureRelease:FireServer(RightWeld, targetRoot)
                end)
                
                task.wait()
            end
        end)
    end
end})

LocalPlayer = Players.LocalPlayer
autoBlobmanEnabled = false
targetCFrame = CFrame.new(466.741, 28, -745.949, 0.906275, -0.000000, -0.422688, 0.000000, 1.000000, -0.000000, 0.422688, 0.000000, 0.906275)
originalPosition = nil
processingBlobmans = {}

function saveCurrentPosition()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        originalPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
        return true
    end
    return false
end

function teleportToPosition(cframe)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = cframe
        LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
        LocalPlayer.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
        return true
    end
    return false
end

function sitOnBlobman(blobman)
    local seat = blobman:FindFirstChild("VehicleSeat")
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
    
    if seat and humanoid and not seat.Occupant then
        seat:Sit(humanoid)
        task.wait(0.08)
        return seat.Occupant == humanoid
    end
    return false
end

function getOffBlobman()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        if humanoid.SeatPart then
            humanoid.Sit = false
            humanoid.Jump = true
            return true
        end
    end
    return false
end

function executeBlobmanSequence(blobman)
    if processingBlobmans[blobman] then return end
    if not SelectedPlayer then return end
    
    processingBlobmans[blobman] = true
    
    task.spawn(function()
        if not saveCurrentPosition() then
            processingBlobmans[blobman] = nil
            return
        end
        
        local blobmanPosition = nil
        if blobman:FindFirstChild("VehicleSeat") then
            blobmanPosition = blobman.VehicleSeat.CFrame
        elseif blobman:FindFirstChild("HumanoidRootPart") then
            blobmanPosition = blobman.HumanoidRootPart.CFrame
        elseif blobman.PrimaryPart then
            blobmanPosition = blobman:GetPrimaryPartCFrame()
        end
        
        if blobmanPosition then
            teleportToPosition(blobmanPosition + Vector3.new(0, 2, 0))
            task.wait(0.12)
        end
        
        if sitOnBlobman(blobman) then
            task.wait(0.12)
        end
        
        teleportToPosition(targetCFrame)
        task.wait(0.14)
        
        getOffBlobman()
        task.wait(0.14)
        
        if originalPosition then
            teleportToPosition(originalPosition)
        end
        
        processingBlobmans[blobman] = nil
    end)
end

workspace.DescendantAdded:Connect(function(descendant)
    if not autoBlobmanEnabled or not SelectedPlayer then return end
    
    if descendant.Name == "CreatureBlobman" and descendant:IsA("Model") then
        local parent = descendant.Parent
        while parent do
            if parent.Name == SelectedPlayer .. "SpawnedInToys" and parent:IsA("Folder") then
                task.wait(0.14)
                executeBlobmanSequence(descendant)
                break
            end
            parent = parent.Parent
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if not autoBlobmanEnabled or not SelectedPlayer then return end
    
    local toysFolder = workspace:FindFirstChild(SelectedPlayer .. "SpawnedInToys")
    if not toysFolder then return end
    
    for _, toy in ipairs(toysFolder:GetDescendants()) do
        if toy.Name == "CreatureBlobman" and toy:IsA("Model") then
            if not processingBlobmans[toy] then
                executeBlobmanSequence(toy)
            end
        end
    end
end)

LoopTab:CreateToggle({
    Name = "Delete-blob (Select someone who has a blobman spawned)",
    CurrentValue = false,
    Flag = "AutoBlobman",
    Callback = function(Value)
        autoBlobmanEnabled = Value
        if Value then
            if SelectedPlayer then
                Rayfield:Notify({
                    Title = "Auto Blobman",
                    Content = "SystÃ¨me activÃ© - Ciblage: " .. SelectedPlayer,
                    Duration = 3
                })
            else
                Rayfield:Notify({
                    Title = "Auto Blobman",
                    Content = "SÃ©lectionnez d'abord un joueur cible",
                    Duration = 3
                })
                autoBlobmanEnabled = false
                return
            end
        else
            Rayfield:Notify({
                Title = "Auto Blobman",
                Content = "SystÃ¨me dÃ©sactivÃ©",
                Duration = 2
            })
            processingBlobmans = {}
        end
    end
})

local BlobmanKickAllToggle = LoopTab:CreateToggle({
    Name = "Blobman Kick All",
    CurrentValue = false,
    Flag = "BlobmanKickAll",
    Callback = function(Value)
        BKA = Value
    end,
})

function BlobKick()
   while true do
      local smegma = true
      local listtype = 1
      local gotsomeone = false
      local listtt = {}
      if BKA then
         listtype = 2
         for _,plr in pairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer then
               if BKAWL and not game.Players.LocalPlayer:IsFriendsWith(plr.UserId) then
                  table.insert(listtt,plr.Name)
               elseif not BKAWL then
                  table.insert(listtt,plr.Name)
               end
            end
         end
      else
         listtt = BlobkickList
      end
      if listtype == 2 then
         if not BKA then
            smegma = false
         end
      end
      for _,plrr in pairs(listtt) do
         if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            j = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
            h = game.Players.LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity
         end
         if smegma and game.Players:FindFirstChild(plrr) and game.Players:FindFirstChild(plrr) ~= game.Players.LocalPlayer then
            local continue = false
            local plr = game.Players:FindFirstChild(plrr)
            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
               if plr.Character.HumanoidRootPart.Massless then
                  if plr.Character.Humanoid.SeatPart then
                     continue = true
                  end
               else
                  continue = true
               end
            end
            if BKA and BKAWL and game.Players.LocalPlayer:IsFriendsWith(game.Players:FindFirstChild(plrr).UserId) then
               continue = false
            end
            while smegma and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and plr and plr.Character and plr.Character.Parent == workspace and plr.Character:FindFirstChild("HumanoidRootPart") and continue do
               if listtype == 2 then
                  if not BKA then
                     smegma = false
                  end
               end
               gotsomeone = true
               continue = false
               if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                  if plr.Character.HumanoidRootPart.Massless then
                     if plr.Character.Humanoid.SeatPart then
                        continue = true
                     end
                  else
                     continue = true
                  end
               end
               if plr.Character.HumanoidRootPart.AssemblyLinearVelocity.Magnitude > 10000 then
                  plr.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
               end
               if plr.Character.HumanoidRootPart.CFrame.Position.Magnitude > 1000000 then
                  continue = false
               end
               if continue and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.SeatPart and game.Players.LocalPlayer.Character.Humanoid.SeatPart.Parent and game.Players.LocalPlayer.Character.Humanoid.SeatPart.Parent.Name == "CreatureBlobman" then
                  blob = game.Players.LocalPlayer.Character.Humanoid.SeatPart.Parent
                  local localtime = tick()
                  if (plr.Character.HumanoidRootPart.CFrame.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position + game.Players.LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity).magnitude > 30 and plr.Character.Parent == workspace then
                     game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = plr.Character:FindFirstChild("HumanoidRootPart").CFrame + (plr.Character:FindFirstChild("HumanoidRootPart").AssemblyLinearVelocity / math.pi)
                     game.Players.LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = plr.Character:FindFirstChild("HumanoidRootPart").AssemblyLinearVelocity
                     task.wait(0.15)
                     if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                        game.ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(plr.Character.HumanoidRootPart,plr.Character.HumanoidRootPart.CFrame)
                     end
                  end
                  local timee = tick()
                  while tick() - timee < 0.25 and plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and blob:FindFirstChild("RightDetector") and blob.RightDetector:FindFirstChild("RightWeld") and blob:FindFirstChild("BlobmanSeatAndOwnerScript") and blob.BlobmanSeatAndOwnerScript:FindFirstChild("CreatureGrab") and blob:FindFirstChild("BlobmanSeatAndOwnerScript") and blob.BlobmanSeatAndOwnerScript:FindFirstChild("CreatureRelease") and continue do
                     game.ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(plr.Character.HumanoidRootPart,plr.Character.HumanoidRootPart.CFrame)
                     task.wait(0.05)
                  end
                  if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and blob:FindFirstChild("RightDetector") and blob.RightDetector:FindFirstChild("RightWeld") and blob:FindFirstChild("BlobmanSeatAndOwnerScript") and blob.BlobmanSeatAndOwnerScript:FindFirstChild("CreatureGrab") and blob:FindFirstChild("BlobmanSeatAndOwnerScript") and blob.BlobmanSeatAndOwnerScript:FindFirstChild("CreatureRelease") then
                     game.ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(plr.Character.HumanoidRootPart)
                     blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(blob.RightDetector,plr.Character.HumanoidRootPart,blob.RightDetector.RightWeld)
                     plr.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0,10^10,0)
                  end
               elseif continue then
                  if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
                     if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.SeatPart then
                        game.Players.LocalPlayer.Character.Humanoid.Sit = false
                     end
                  end
                  if blob and blob:FindFirstChild("VehicleSeat") then
                     if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
                        blob.VehicleSeat:Sit(game.Players.LocalPlayer.Character.Humanoid)
                     end
                     task.wait(0.1)
                  else
                     local foundblob = false
                     blob = nil
                     for _,itm in pairs(workspace[game.Players.LocalPlayer.Name.."SpawnedInToys"]) do
                        if itm.Name == "CreatureBlobman" and itm:FindFirstChild("VehicleSeat") then
                           foundblob = true
                           blob = itm
                        elseif itm.Name == "CreatureBlobman" then
                           while itm do
                              game.ReplicatedStorage.MenuToys.DestroyToy:FireServer(itm)
                              task.wait(0.1)
                           end
                        end
                     end
                     if blob and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
                        blob.VehicleSeat:Sit(game.Players.LocalPlayer.Character.Humanoid)
                     end
                     if not foundblob then
                        task.wait(1)
                        if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                           while smegma and not blob do
                              if listtype == 2 then
                                 if not BKA then
                                    smegma = false
                                 end
                              end
                              if workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys"):FindFirstChild("CreatureBlobman") then
                                 blob = workspace:FindFirstChild(game.Players.LocalPlayer.Name.."SpawnedInToys"):FindFirstChild("CreatureBlobman")
                              end
                              if not blob then
                                 task.spawn(function()
                                    game.ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer("CreatureBlobman",CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position)+Vector3.new(0,0,15),Vector3.new(0,0,0))
                                 end)
                              end
                              task.wait()
                           end
                        end
                     end
                  end
               end
               task.wait(0.1)
            end
         end
         if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = j
            game.Players.LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = h
         end
      end
      if not gotsomeone and blob then
         if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.SeatPart and game.Players.LocalPlayer.Character.Humanoid.SeatPart.Parent == blob then
            game.Players.LocalPlayer.Character.Humanoid.Sit = false
         end
         task.wait()
         if blob and blob:FindFirstChild("HumanoidRootPart") then
            blob.HumanoidRootPart.CFrame = CFrame.new(-1e6,-1e6,-1e6)
         end
      end
      task.wait()
   end
end

task.spawn(BlobKick)

local WhitelistFriendsToggle = LoopTab:CreateToggle({
   Name = "Whitelist Friends",
   CurrentValue = true,
   Flag = "WhitelistFriends",
   Callback = function(Value)
      BKAWL = Value
   end,
})

local GrabTab = Window:CreateTab("Grab", "hand")

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local localPlayer = Players.LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()

localPlayer.CharacterAdded:Connect(function(character)
    playerCharacter = character
end)

GrabTab:CreateSection("Kill Grab Features")

local killGrabEnabled = false

local function handleNewGrabParts(grabPartsModel)
    task.wait(0.05)
    local grabPart = grabPartsModel:FindFirstChild("GrabPart")
    if grabPart and grabPart:FindFirstChild("WeldConstraint") then
        local targetPart = grabPart.WeldConstraint.Part1
        if targetPart and targetPart.Parent ~= playerCharacter then
            local targetHumanoid = targetPart.Parent:FindFirstChildOfClass("Humanoid")
            if targetHumanoid then
                pcall(function()
                    targetHumanoid.Health = 0
                    targetPart.Parent:BreakJoints()
                end)
            end
        end
    end
end

workspace.ChildAdded:Connect(function(child)
    if killGrabEnabled and child:IsA("Model") and child.Name == "GrabParts" then
        handleNewGrabParts(child)
    end
end)

GrabTab:CreateToggle({
    Name = "Kill Grab",
    CurrentValue = false,
    Flag = "KillGrabToggle",
    Callback = function(value)
        killGrabEnabled = value
    end
})

GrabTab:CreateSection("For NiggaMan")

_G.strength = 750
local strengthConnection

GrabTab:CreateSlider({
    Name = "Throw Power",
    Range = {1, 20000},
    Increment = 1,
    Suffix = "",
    CurrentValue = 750,
    Flag = "ThrowPower",
    Callback = function(Value)
        _G.strength = Value
    end
})

GrabTab:CreateToggle({
    Name = "Throw Strength",
    CurrentValue = false,
    Flag = "ThrowStrength",
    Callback = function(Value)
        if Value then
            strengthConnection = workspace.ChildAdded:Connect(function(model)
                if model.Name == "GrabParts" then
                    local partToImpulse = model.GrabPart.WeldConstraint.Part1
                    if partToImpulse then
                        local velocityObj = Instance.new("BodyVelocity", partToImpulse)
                        
                        model:GetPropertyChangedSignal("Parent"):Connect(function()
                            if not model.Parent then
                                if UserInputService:GetLastInputType() == Enum.UserInputType.MouseButton2 then
                                    velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                    velocityObj.Velocity = workspace.CurrentCamera.CFrame.LookVector * _G.strength
                                    game:GetService("Debris"):AddItem(velocityObj, 1)
                                else
                                    velocityObj:Destroy()
                                end
                            end
                        end)
                    end
                end
            end)
        elseif strengthConnection then
            strengthConnection:Disconnect()
        end
    end
})

GrabTab:CreateSection("Noclip & Massless Grab")

function noclipGrab()
    local player = game.Players.LocalPlayer

    noclipCoroutine = coroutine.create(function()
        while true do
            local success, err = pcall(function()
                local grabFolder = workspace:FindFirstChild("GrabParts")
                if grabFolder then
                    local grabPart = grabFolder:FindFirstChild("GrabPart")
                    if grabPart and grabPart:FindFirstChild("WeldConstraint") then
                        local grabbed = grabPart.WeldConstraint.Part1
                        if grabbed and grabbed.Parent then
                            for _, part in pairs(grabbed.Parent:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.CanCollide = false
                                end
                            end
                        else
                            for _, part in pairs(player.Character:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.CanCollide = true
                                end
                            end
                        end
                    else
                        for _, part in pairs(player.Character:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = true
                            end
                        end
                    end
                else
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                end
            end)
            task.wait(0.05)
        end
    end)

    coroutine.resume(noclipCoroutine)
end

getgenv().NoclipGrabConnection = nil

GrabTab:CreateToggle({
    Name = "Noclip Grab",
    CurrentValue = false,
    Flag = "ToggleNoclipGrab",
    Callback = function(v)
        if getgenv().NoclipGrabConnection then
            getgenv().NoclipGrabConnection:Disconnect()
            getgenv().NoclipGrabConnection = nil
        end
        function GetGrabbedCharacter()
            local g = workspace:FindFirstChild("GrabParts")
            if not g then return nil end
            local gp = g:FindFirstChild("GrabPart")
            if not gp then return nil end
            local weld = gp:FindFirstChild("WeldConstraint") or gp:FindFirstChild("Weld")
            if not weld then return nil end
            return weld.Part1 and weld.Part1.Parent or nil
        end
        if not v then
            local char = GetGrabbedCharacter()
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored then part.CanCollide = true end
                end
            end
            return
        end
        getgenv().NoclipGrabConnection = RunService.Heartbeat:Connect(function()
            local char = GetGrabbedCharacter()
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored then part.CanCollide = false end
                end
            end
        end)
    end,
})


GrabTab:CreateSection("Heavy Object Grab")

GrabTab:CreateToggle({
    Name = "Grab Heavy Objects Normally",
    Default = false,
    Callback = function(enabled)
        local maxForce = enabled and math.huge or 30000
        local maxTorque = enabled and math.huge or 60000

        for _, dragPart in pairs({ReplicatedStorage:FindFirstChild("GrabParts") and ReplicatedStorage.GrabParts:FindFirstChild("DragPart"),
                                  Workspace:FindFirstChild("GrabParts") and Workspace.GrabParts:FindFirstChild("DragPart")}) do
            if dragPart then
                if dragPart:FindFirstChild("AlignPosition") then
                    dragPart.AlignPosition.MaxForce = maxForce
                end
                if dragPart:FindFirstChild("AlignOrientation") then
                    dragPart.AlignOrientation.MaxTorque = maxTorque
                end
            end
        end
    end
})

GrabTab:CreateSection("Anchor Grab")

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
local SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")

local localPlayer = Players.LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()

localPlayer.CharacterAdded:Connect(function(character)
    playerCharacter = character
end)

-- Storage
local anchoredParts = {}
local anchoredConnections = {}
local anchorGrabCoroutine = nil

-- Helper Functions
local function isDescendantOf(target, other)
    local currentParent = target.Parent
    while currentParent do
        if currentParent == other then
            return true
        end
        currentParent = currentParent.Parent
    end
    return false
end

local function cleanupConnections(connectionTable)
    for _, connection in ipairs(connectionTable) do
        if connection and connection.Connected then
            connection:Disconnect()
        end
    end
    for i = #connectionTable, 1, -1 do
        table.remove(connectionTable, i)
    end
end

local function createHighlight(parent)
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.Occluded
    highlight.FillTransparency = 1
    highlight.Name = "Highlight"
    highlight.OutlineColor = Color3.new(0, 0, 1)
    highlight.OutlineTransparency = 0.5
    highlight.Parent = parent
    return highlight
end

local function onPartOwnerAdded(descendant, primaryPart)
    if descendant.Name == "PartOwner" then
        local highlight = primaryPart.Parent:FindFirstChild("Highlight")
        if highlight then
            if descendant.Value ~= localPlayer.Name then
                highlight.OutlineColor = Color3.new(1, 0, 0)
            else
                highlight.OutlineColor = Color3.new(0, 0, 1)
            end
        end
    end
end

local function createBodyMovers(part, position, rotation)
    local bodyPosition = Instance.new("BodyPosition")
    local bodyGyro = Instance.new("BodyGyro")

    bodyPosition.P = 15000
    bodyPosition.D = 200
    bodyPosition.MaxForce = Vector3.new(5000000, 5000000, 5000000)
    bodyPosition.Position = position
    bodyPosition.Parent = part

    bodyGyro.P = 15000
    bodyGyro.D = 200
    bodyGyro.MaxTorque = Vector3.new(5000000, 5000000, 5000000)
    bodyGyro.CFrame = rotation
    bodyGyro.Parent = part
end

local function anchorGrab()
    while true do
        pcall(function()
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then return end

            local grabPart = grabParts:FindFirstChild("GrabPart")
            if not grabPart then return end

            local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then return end

            local primaryPart = weldConstraint.Part1.Parent and weldConstraint.Part1.Parent.PrimaryPart
            if not primaryPart then return end

            if isDescendantOf(primaryPart, workspace.Map) then return end
            
            for _, player in pairs(Players:GetChildren()) do
                if player.Character and isDescendantOf(primaryPart, player.Character) then 
                    return 
                end
            end

            if not table.find(anchoredParts, primaryPart) then
                local highlight = createHighlight(primaryPart.Parent)
                table.insert(anchoredParts, primaryPart)
                
                local connection = primaryPart.Parent.DescendantAdded:Connect(function(descendant)
                    onPartOwnerAdded(descendant, primaryPart)
                end)
                table.insert(anchoredConnections, connection)
            end

            for _, child in ipairs(primaryPart:GetChildren()) do
                if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                    child:Destroy()
                end
            end

            while workspace:FindFirstChild("GrabParts") do
                wait()
            end
            
            createBodyMovers(primaryPart, primaryPart.Position, primaryPart.CFrame)
        end)
        wait()
    end
end

local function cleanupAnchoredParts()
    for _, part in ipairs(anchoredParts) do
        if part then
            if part:FindFirstChild("BodyPosition") then
                part.BodyPosition:Destroy()
            end
            if part:FindFirstChild("BodyGyro") then
                part.BodyGyro:Destroy()
            end
            if part.Parent and part.Parent:FindFirstChild("Highlight") then
                part.Parent.Highlight:Destroy()
            end
        end
    end

    cleanupConnections(anchoredConnections)
    anchoredParts = {}
end

GrabTab:CreateParagraph({
    Title = "Object-Only", 
    Content = "These effects only apply on objects."
})

GrabTab:CreateToggle({
    Name = "Anchor Grab",
    CurrentValue = false,
    Flag = "AnchorGrab",
    Callback = function(enabled)
        if enabled then
            if not anchorGrabCoroutine or coroutine.status(anchorGrabCoroutine) == "dead" then
                anchorGrabCoroutine = coroutine.create(anchorGrab)
                coroutine.resume(anchorGrabCoroutine)
                
                Rayfield:Notify({
                    Title = "Anchor Grab",
                    Content = "Enabled - Grab objects to anchor them!",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        else
            if anchorGrabCoroutine and coroutine.status(anchorGrabCoroutine) ~= "dead" then
                coroutine.close(anchorGrabCoroutine)
                anchorGrabCoroutine = nil
                
                Rayfield:Notify({
                    Title = "Anchor Grab",
                    Content = "Disabled",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end
    end
})

GrabTab:CreateParagraph({
    Title = "Anchor grab information", 
    Content = "If someone grabs your anchored parts, they will fall and you will need to position them again!"
})

GrabTab:CreateButton({
    Name = "Unanchor parts",
    Callback = function()
        cleanupAnchoredParts()
        
        Rayfield:Notify({
            Title = "Cleanup",
            Content = "All anchored parts removed!",
            Duration = 3,
            Image = 4483362458
        })
    end
})

GrabTab:CreateParagraph({
    Title = "Status", 
    Content = "Anchored parts will be highlighted in blue when you own them, red when others own them."
})

GrabTab:CreateSection("Massless Grab")

local Sense = 30
local Massless = nil

GrabTab:CreateToggle({
    Name = "Enable Massless Grab",
    CurrentValue = false,
    Flag = "MasslessGrab",
    Callback = function(v)
        if v then
            Massless = workspace.ChildAdded:Connect(function(r)
                if r.Name == "GrabParts" then
                    while workspace:FindFirstChild("GrabParts") do
                        task.wait()
                        local dp = r:FindFirstChild("DragPart")
                        if dp and dp:FindFirstChild("AlignPosition") and dp:FindFirstChild("AlignOrientation") then
                            dp.AlignPosition.Responsiveness = Sense
                            dp.AlignPosition.MaxForce = math.huge
                            dp.AlignPosition.MaxVelocity = math.huge
                            dp.AlignOrientation.Responsiveness = Sense
                            dp.AlignOrientation.MaxTorque = math.huge
                        end
                    end
                end
            end)
        else
            if Massless then Massless:Disconnect() Massless = nil end
        end
    end,
})

GrabTab:CreateInput({
    Name = "Massless Sense",
    CurrentValue = tostring(Sense),
    PlaceholderText = "Enter sense value",
    RemoveTextAfterFocusLost = false,
    Flag = "MasslessSenseInput",
    Callback = function(Text)
        local v = tonumber(Text)
        if v and v > 0 then Sense = v end
    end,
})

GrabTab:CreateSection("Miscellaneous")

GrabTab:CreateToggle({
    Name = "Freeze-Ocean",
    Default = false,
    Callback = function(Value)
        for _, prt in pairs(workspace.Map.AlwaysHereTweenedObjects.Ocean.Object.ObjectModel:GetChildren()) do
            prt.Anchored = Value
            if Value then
                prt.CFrame = prt.CFrame + Vector3.new(0, -52 - prt.CFrame.Position.Y, 0)
            end
        end
    end
})

GrabTab:CreateToggle({
    Name = "Plot-Item Collision",
    Default = false,
    Callback = function(Value)
        for _, plot in pairs(workspace.PlotItems:GetChildren()) do
            if plot.Name ~= "PlayersInPlots" then
                for _, prt in pairs(plot:GetDescendants()) do
                    if prt:IsA("BasePart") then
                        prt.CollisionGroup = Value and "Items" or "PlotItems"
                    end
                end
            end
        end
    end
})


Tab = Window:CreateTab("Anchor", "anchor")

Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
TweenService = game:GetService("TweenService")
ReplicatedStorage = game:GetService("ReplicatedStorage")
ContextActionService = game:GetService("ContextActionService")
LocalPlayer = game:GetService("Players").LocalPlayer
SpawnedToys = Workspace:WaitForChild(LocalPlayer.Name .. "SpawnedInToys")
DeleteToyRE = ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("DestroyToy")
SetNetworkOwnerRE = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")

AnchoredObjects = {}
CompiledGroups = {}
SB_LineTransparencyValue = Instance.new("NumberValue")
SB_SurfaceTransparencyValue = Instance.new("NumberValue")
SB_AnchoredColor3 = Instance.new("Color3Value")
SB_AnchoredColor3Surface = Instance.new("Color3Value")
SB_GlueColor3 = Instance.new("Color3Value")
SB_GlueColor3Surface = Instance.new("Color3Value")
SB_MainGlueColor3 = Instance.new("Color3Value")
SB_MainGlueColor3Surface = Instance.new("Color3Value")

SB_LineTransparencyValue.Value = 0
SB_SurfaceTransparencyValue.Value = 0.5
SB_AnchoredColor3.Value = Color3.fromRGB(194, 194, 194)
SB_AnchoredColor3Surface.Value = Color3.fromRGB(209, 0, 0)
SB_GlueColor3.Value = Color3.fromRGB(255, 0, 57)
SB_GlueColor3Surface.Value = Color3.fromRGB(244, 244, 244)
SB_MainGlueColor3.Value = Color3.fromRGB(123, 85, 38)
SB_MainGlueColor3Surface.Value = Color3.fromRGB(0, 244, 36)

ESPEnabled = {
    Anchored = false,
    Group = false
}

AutoRecoverEnabled = false
RecoverCoroutine = nil

function RecoverParts()
    while AutoRecoverEnabled do
        success, err = pcall(function()
            character = LocalPlayer.Character
            if character and character:FindFirstChild("Head") and character:FindFirstChild("HumanoidRootPart") then
                humanoidRootPart = character.HumanoidRootPart
                
                for model, data in pairs(AnchoredObjects) do
                    coroutine.wrap(function()
                        if model and data.PartAnchored then
                            part = data.PartAnchored
                            distance = (part.Position - humanoidRootPart.Position).Magnitude
                            
                            if distance > 30 then
                                partOwner = part:FindFirstChild("PartOwner")
                                if not partOwner or partOwner.Value ~= LocalPlayer.Name then
                                    humanoidRootPart.CFrame = CFrame.new(part.Position + Vector3.new(0, 5, 0))
                                    task.wait(0.1)
                                    SetNetworkOwnerRE:FireServer(part, lookAt(humanoidRootPart.Position, part.Position))
                                end
                            else
                                partOwner = part:FindFirstChild("PartOwner")
                                if not partOwner or partOwner.Value ~= LocalPlayer.Name then
                                    SetNetworkOwnerRE:FireServer(part, lookAt(humanoidRootPart.Position, part.Position))
                                end
                            end
                        end
                    end)()
                end
                
                for _, groupData in ipairs(CompiledGroups) do
                    if groupData.primaryPart then
                        coroutine.wrap(function()
                            primaryModel = groupData.primaryPart
                            if primaryModel then
                                primaryPart = primaryModel.PrimaryPart or primaryModel:FindFirstChildOfClass("BasePart")
                                if primaryPart then
                                    distance = (primaryPart.Position - humanoidRootPart.Position).Magnitude
                                    
                                    if distance > 30 then
                                        partOwner = primaryPart:FindFirstChild("PartOwner")
                                        if not partOwner or partOwner.Value ~= LocalPlayer.Name then
                                            humanoidRootPart.CFrame = CFrame.new(primaryPart.Position + Vector3.new(0, 5, 0))
                                            task.wait(0.1)
                                            SetNetworkOwnerRE:FireServer(primaryPart, lookAt(humanoidRootPart.Position, primaryPart.Position))
                                        end
                                    else
                                        partOwner = primaryPart:FindFirstChild("PartOwner")
                                        if not partOwner or partOwner.Value ~= LocalPlayer.Name then
                                            SetNetworkOwnerRE:FireServer(primaryPart, lookAt(humanoidRootPart.Position, primaryPart.Position))
                                        end
                                    end
                                end
                            end
                        end)()
                    end
                end
            end
        end)
        task.wait(0.05)
    end
end

function CreateESP(object, espType)
    if not object or not object:IsA("Model") and not object:IsA("BasePart") then return end
    
    existingESP = object:FindFirstChild("ESP_" .. espType)
    
    if existingESP then
        existingESP:Destroy()
    end
    
    highlight = Instance.new("Highlight")
    highlight.Name = "ESP_" .. espType
    highlight.Adornee = object
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    
    if espType == "Anchored" then
        highlight.FillColor = Color3.fromRGB(194, 194, 194)
        highlight.OutlineColor = Color3.fromRGB(209, 0, 0)
    elseif espType == "Group" then
        highlight.FillColor = Color3.fromRGB(255, 0, 57)
        highlight.OutlineColor = Color3.fromRGB(244, 244, 244)
    end
    
    highlight.Parent = object
    return highlight
end

function RemoveESP(object, espType)
    if not object then return end
    existingESP = object:FindFirstChild("ESP_" .. espType)
    if existingESP then
        existingESP:Destroy()
    end
end

function UpdateAllESP()
    for model, data in pairs(AnchoredObjects) do
        if ESPEnabled.Anchored and model:GetAttribute("IsAnchored") and not IsInCompileGroup(model) then
            CreateESP(model, "Anchored")
        else
            RemoveESP(model, "Anchored")
        end
    end
    for _, groupData in ipairs(CompiledGroups) do
        if groupData.primaryPart then
            for _, item in pairs(groupData.group) do
                if ESPEnabled.Group then
                    CreateESP(item.model, "Group")
                else
                    RemoveESP(item.model, "Group")
                end
            end
        end
    end
end

function lookAt(position, target)
    direction = (target - position).Unit
    right = direction:Cross(Vector3.new(0, 1, 0))
    up = right:Cross(direction)
    return CFrame.fromMatrix(position, right, up)
end

function SetNetworkOwnership(part)
    if part and typeof(part) == "Instance" then
        distance = LocalPlayer:DistanceFromCharacter(part.Position)
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and distance <= 30 then
            SetNetworkOwnerRE:FireServer(part, lookAt(LocalPlayer.Character.HumanoidRootPart.Position, part.Position))
        end
    end
end

function CheckNetworkOwnerShipOnPart(part, returnOwner)
    if typeof(part) == "Instance" and part:FindFirstChild("PartOwner") and part.PartOwner.Value == LocalPlayer.Name then
        return not returnOwner and true or part.PartOwner
    end
end

function SetNetworkOwnershipOnce(part)
    distance = LocalPlayer:DistanceFromCharacter(part.Position)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        if CheckNetworkOwnerShipOnPart(part) then
            return true
        end
        if distance <= 30 then
            SetNetworkOwnerRE:FireServer(part, lookAt(LocalPlayer.Character.HumanoidRootPart.Position, part.Position))
        end
    end
end

function GetDistanceFromCharacter(position)
    return LocalPlayer:DistanceFromCharacter(position)
end

function AnchorObjectEffect(part)
    attachment = Instance.new("Attachment")
    sound = Instance.new("Sound", attachment)
    sound.Name = "soundeffect"
    sound.SoundId = "rbxassetid://17481582653"
    attachment.Parent = part
    attachment.soundeffect:Play()
    game:GetService("Debris"):AddItem(attachment)
end

function ChangeSBstate(selectionBox, state)
    if typeof(selectionBox) == "Instance" and selectionBox:IsA("SelectionBox") then
        selectionBox:SetAttribute("SB_State", state)
        if state == "Anchored" then
            selectionBox.Color3 = SB_AnchoredColor3.Value
            selectionBox.SurfaceColor3 = SB_AnchoredColor3Surface.Value
        elseif state == "Glue" then
            selectionBox.Color3 = SB_GlueColor3.Value
            selectionBox.SurfaceColor3 = SB_GlueColor3Surface.Value
        elseif state == "GluePrimary" then
            selectionBox.Color3 = SB_MainGlueColor3.Value
            selectionBox.SurfaceColor3 = SB_MainGlueColor3Surface.Value
        else
            selectionBox.Color3 = Color3.fromRGB(111, 32, 12)
            selectionBox.SurfaceColor3 = Color3.fromRGB(163, 12, 0)
        end
    end
end

function setanchorObject(part)
    if typeof(part) == "Instance" and part.Parent and (part.Parent:IsA("Model") or part.Parent:IsA("Folder")) then
        parentModel = part.Parent
        if parentModel:IsA("Folder") or parentModel == Workspace then
            parentModel = part
        end
        if parentModel:GetAttribute("IsAnchored") or parentModel:GetAttribute("Glue") then
            unAnchorObject(part)
        else
            bodyPosition = parentModel:FindFirstChild("AnchorPositionBody") or part:FindFirstChild("AnchorPositionBody") or Instance.new("BodyPosition")
            bodyGyro = parentModel:FindFirstChild("AnchorGyroBody") or part:FindFirstChild("AnchorGyroBody") or Instance.new("BodyGyro")
            selectionBox = parentModel:FindFirstChild("ObjectState") or Instance.new("SelectionBox")
            connections = {}
            maxTorque = Vector3.new(math.huge, math.huge, math.huge)
            zeroVector = Vector3.new(0, 0, 0)
            originalPosition = part.Position
            
            bodyPosition.Name = "AnchorPositionBody"
            bodyPosition.Position = part.Position
            bodyPosition.Parent = part
            bodyGyro.Name = "AnchorGyroBody"
            bodyGyro.Parent = part
            bodyGyro.CFrame = part.CFrame
            bodyGyro.D = 950
            bodyGyro.P = 40000
            bodyPosition.P = 40000
            bodyPosition.D = 950
            selectionBox.Name = "ObjectState"
            selectionBox.LineThickness = 0.025
            selectionBox.SurfaceTransparency = SB_SurfaceTransparencyValue.Value
            selectionBox.Transparency = SB_LineTransparencyValue.Value
            selectionBox.Visible = true
            selectionBox.Parent = parentModel
            selectionBox.Adornee = parentModel
            
            function EnableAnchor()
                if parentModel:GetAttribute("IsAnchored") or parentModel:GetAttribute("Glue") then
                    bodyGyro.MaxTorque = maxTorque
                    bodyPosition.MaxForce = maxTorque
                end
                if parentModel:GetAttribute("GluePrimary") and not parentModel:GetAttribute("IsAnchored") then
                    ChangeSBstate(selectionBox, "GluePrimary")
                elseif parentModel:GetAttribute("Glue") and not parentModel:GetAttribute("IsAnchored") then
                    ChangeSBstate(selectionBox, "Glue")
                else
                    ChangeSBstate(selectionBox, "Anchored")
                end
            end
            
            function DisableAnchor()
                bodyGyro.MaxTorque = Vector3.new()
                bodyPosition.MaxForce = Vector3.new()
                ChangeSBstate(selectionBox)
                parentModel:SetAttribute("AnchorOwnership", false)
            end
            
            connections[1] = parentModel.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "PartOwner" then
                    if descendant.Value ~= LocalPlayer.Name then
                        DisableAnchor()
                    else
                        EnableAnchor()
                    end
                end
            end)
            
            connections[2] = parentModel.DescendantRemoving:Connect(function(descendant)
                if descendant.Name == "PartOwner" and descendant.Value == LocalPlayer.Name then
                    DisableAnchor()
                end
            end)
            
            task.spawn(function()
                while bodyPosition.Parent and not parentModel:GetAttribute("Glue") do
                    if parentModel:GetAttribute("IsAnchored") then
                        bodyGyro.MaxTorque = maxTorque
                        bodyPosition.MaxForce = maxTorque
                    else
                        bodyGyro.MaxTorque = zeroVector
                        bodyPosition.MaxForce = zeroVector
                    end
                    bodyPosition.Position = originalPosition + Vector3.new(0, 0.001, 0)
                    task.wait()
                    bodyPosition.Position = originalPosition
                end
            end)
            
            AnchoredObjects[parentModel] = {
                BodyPosition = bodyPosition,
                BodyGyro = bodyGyro,
                PartAnchored = part,
                SB = selectionBox,
                Connections = connections,
                Model = parentModel
            }
            AnchorObjectEffect(part)
            parentModel:SetAttribute("IsAnchored", true)
            EnableAnchor()
            if ESPEnabled.Anchored then
                CreateESP(parentModel, "Anchored")
            end
        end
    end
end

function unAnchorObject(part)
    if typeof(part) == "Instance" and part.Parent and (part.Parent:IsA("Model") or part.Parent:IsA("Folder")) then
        parentModel = part.Parent
        isAnchored = parentModel:GetAttribute("IsAnchored")
        isGluePrimary = parentModel:GetAttribute("GluePrimary")
        
        if not parentModel:IsA("Folder") and parentModel ~= Workspace then
            part = parentModel
        end
        if AnchoredObjects[part] and isAnchored then
            data = AnchoredObjects[part]
            data.BodyPosition.Parent = part
            data.BodyGyro.Parent = part
            data.PartAnchored = nil
            if isGluePrimary then
                ChangeSBstate(data.SB, "GluePrimary")
            else
                data.SB.Visible = false
            end
            for _, connection in pairs(data.Connections) do
                connection:Disconnect()
            end
            part:SetAttribute("IsAnchored", false)
            part:SetAttribute("AnchorOwnership", false)
            
            RemoveESP(part, "Anchored")
            
            if not isGluePrimary then
                AnchoredObjects[part] = nil
            end
        end
    end
end

function DisconnectObject(model)
    if typeof(model) == "Instance" and AnchoredObjects[model] then
        data = AnchoredObjects[model]
        data.BodyPosition.Parent = model
        data.BodyGyro.Parent = model
        data.PartAnchored = nil
        data.SB.Visible = false
        for _, connection in pairs(data.Connections) do
            connection:Disconnect()
        end
        model:SetAttribute("IsAnchored", nil)
        model:SetAttribute("AnchorOwnership", nil)
        model:SetAttribute("Glue", nil)
        model:SetAttribute("GluePrimary", nil)
        
        RemoveESP(model, "Anchored")
        RemoveESP(model, "Group")
        
        AnchoredObjects[model] = nil
    end
end

function unAnchorAll()
    for _, data in pairs(AnchoredObjects) do
        if typeof(data.PartAnchored) == "Instance" then
            unAnchorObject(data.PartAnchored)
        end
    end
end

function anchorfunc()
    grabParts = Workspace:FindFirstChild("GrabParts")
    
    function IsValidPart(part)
        if part and not (part:IsDescendantOf(Workspace.Map) or part.Anchored) then
            return true
        end
    end
    
    if grabParts then
        heldPart = grabParts.GrabPart.WeldConstraint.Part1
        if IsValidPart(heldPart) then
            setanchorObject(heldPart)
        end
    elseif LocalPlayer.Character then
        character = LocalPlayer.Character
        camPartName = LocalPlayer.Character and "CamPart" or nil
        hitPart, _ = Workspace:FindPartOnRayWithIgnoreList(Ray.new(character[camPartName].Position, LocalPlayer.Character.CamPart.CFrame.lookVector * 5000), {character})
        if hitPart and hitPart.Parent and hitPart.Parent:IsA("Model") and hitPart.Parent:GetAttribute("IsAnchored") and IsValidPart(hitPart) then
            setanchorObject(hitPart)
        end
    end
end

function anchorobject(actionName, inputState, _)
    if actionName == "AnchorK" and inputState == Enum.UserInputState.Begin then
        anchorfunc()
    end
end

function IsInCompileGroup(model)
    for _, groupData in ipairs(CompiledGroups) do
        if groupData.primaryPart then
            for _, item in pairs(groupData.group) do
                if item.model and item.model == model and (item.model:GetAttribute("Glue") or item.model:GetAttribute("GluePrimary")) and not item.model:GetAttribute("IsAnchored") then
                    return true
                end
            end
        end
    end
    return false
end

function CheckPrimaryPartOnCompileGroup(part)
    for _, groupData in ipairs(CompiledGroups) do
        if groupData.primaryPart and groupData.primaryPart == part and groupData.primaryPart:GetAttribute("IsAnchored") then
            return true
        end
    end
    return false
end

function IsHoldingAnchoredPart()
    grabParts = Workspace:FindFirstChild("GrabParts")
    heldModel = nil
    if grabParts then
        heldPart = grabParts.GrabPart.WeldConstraint.Part1
        if heldPart then
            for model, _ in pairs(AnchoredObjects) do
                if heldPart:IsDescendantOf(model) then
                    heldModel = AnchoredObjects[model].Model
                    break
                end
            end
        end
    end
    return heldModel
end

function CountCompileGroups()
    count = 0
    for _, _ in ipairs(CompiledGroups) do
        count = count + 1
    end
    return count
end

function ObjectStateBillboardGUI(model, stateText)
    billboard = model:FindFirstChild("ObjectText")
    if not billboard then
        billboard = Instance.new("BillboardGui")
        textLabel = Instance.new("TextLabel")
        billboard.Name = "ObjectText"
        billboard.Parent = model
        billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        billboard.Active = true
        billboard.Adornee = model
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(3, 0, 3, 0)
        billboard.Enabled = false
        textLabel.Name = "State"
        textLabel.Parent = billboard
        textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
        textLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.BackgroundTransparency = 1
        textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
        textLabel.Size = UDim2.new(1, 5, 0.340000004, 5)
        textLabel.Font = Enum.Font.SourceSans
        textLabel.Text = ""
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.TextScaled = true
        textLabel.TextSize = 28
        textLabel.TextStrokeTransparency = 0
        textLabel.TextWrapped = true
    end
    if typeof(stateText) ~= "string" then
        billboard.Enabled = false
    else
        billboard.State.TextColor3 = Color3.fromRGB(255, 255, 255)
        billboard.State.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        if stateText == "Anchored" then
            billboard.State.TextColor3 = Color3.fromRGB(112, 186, 255)
            billboard.State.TextStrokeColor3 = Color3.fromRGB(0, 0, 127)
        elseif stateText == "Disconnected" then
            billboard.State.TextColor3 = Color3.fromRGB(255, 0, 0)
            billboard.State.TextStrokeColor3 = Color3.fromRGB(67, 0, 0)
        end
        billboard.State.Text = stateText
        billboard.Enabled = true
    end
end

function RemoveCompileGroup(primaryPart)
    for index, groupData in ipairs(CompiledGroups) do
        if groupData.primaryPart and groupData.primaryPart == primaryPart then
            for _, constraint in pairs(groupData.Nc_Group) do
                constraint:Destroy()
            end
            ObjectStateBillboardGUI(primaryPart)
            for _, connection in pairs(groupData.gC) do
                connection:Disconnect()
            end
            for _, item in pairs(groupData.group) do
                item.model:SetAttribute("Glue", false)
                item.model:SetAttribute("GluePrimary", false)
                item.model:SetAttribute("IsAnchored", false)
                RemoveESP(item.model, "Group")
            end
            table.remove(CompiledGroups, index)
        end
    end
end

function RemoveGroupCompileFromName(groupName)
    for _, groupData in ipairs(CompiledGroups) do
        if groupData.gN == groupName then
            for _, item in pairs(groupData.group) do
                DisconnectObject(item.model)
            end
            RemoveCompileGroup(groupData.primaryPart)
        end
    end
end

function CreateNoCollisionConstraintsCompile(primaryPart)
    for _, groupData in ipairs(CompiledGroups) do
        if groupData.primaryPart and groupData.primaryPart == primaryPart then
            for _, item in pairs(groupData.group) do
                if item.model == primaryPart and item.model and primaryPart then
                    for _, basePart1 in ipairs(item.model:GetChildren()) do
                        if basePart1:IsA("BasePart") then
                            for _, otherItem in pairs(groupData.group) do
                                for _, basePart2 in ipairs(otherItem.model:GetChildren()) do
                                    if basePart2:IsA("BasePart") then
                                        noCollision = Instance.new("NoCollisionConstraint", basePart1)
                                        noCollision.Part0 = basePart1
                                        noCollision.Part1 = basePart2
                                        noCollision.Enabled = true
                                        table.insert(groupData.Nc_Group, noCollision)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

function UpdateGroupPositions(primaryPart)
    for _, groupData in ipairs(CompiledGroups) do
        if groupData.primaryPart and groupData.primaryPart == primaryPart then
            for _, item in ipairs(groupData.group) do
                if item.model ~= primaryPart then
                    primaryPartReference = primaryPart.PrimaryPart or primaryPart:FindFirstChildOfClass("BasePart")
                    if primaryPartReference and primaryPart then
                        if item.bodypos then
                            item.bodypos.P = 40000
                            item.bodypos.D = 200
                            item.bodypos.Position = (primaryPartReference.CFrame * item.offset).Position
                            task.wait()
                            item.bodypos.Position = item.bodypos.Position + Vector3.new(0, 0.002, 0)
                        end
                        if item.bodygyro then
                            item.bodygyro.P = 40000
                            item.bodygyro.D = 200
                            item.bodygyro.CFrame = primaryPartReference.CFrame * item.offset
                        end
                    end
                end
            end
        end
    end
end

function CompileObjects()
    anchoredCount = 0
    
    for model, _ in pairs(AnchoredObjects) do
        if not IsInCompileGroup(model) then
            anchoredCount = anchoredCount + 1
        end
    end
    
    if anchoredCount == 0 then
        game.StarterGui:SetCore("SendNotification", {
            Title = "Error",
            Text = "No anchored parts found",
            Duration = 5
        })
        return
    elseif anchoredCount == 1 then
        game.StarterGui:SetCore("SendNotification", {
            Title = "Error",
            Text = "Needs at least 2 anchored objects",
            Duration = 5
        })
        return
    else
        heldAnchoredModel = IsHoldingAnchoredPart()
        if heldAnchoredModel then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Success",
                Text = "Compiled " .. anchoredCount .. " Toys together",
                Duration = 5
            })
            
            for model, _ in pairs(AnchoredObjects) do
                if not IsInCompileGroup(model) and CheckPrimaryPartOnCompileGroup(model) then
                    RemoveCompileGroup(model)
                end
            end
            
            groupName = "Group " .. CountCompileGroups() + 1
            groupItems = {}
            groupConnections = {}
            
            for model, data in pairs(AnchoredObjects) do
                if not IsInCompileGroup(model) then
                    anchoredPart = data.PartAnchored
                    offset = heldAnchoredModel.PrimaryPart.CFrame:toObjectSpace(anchoredPart.CFrame)
                    model:SetAttribute("IsAnchored", false)
                    
                    RemoveESP(model, "Anchored")
                    
                    if model == heldAnchoredModel then
                        data.BodyGyro.MaxTorque = Vector3.new()
                        data.BodyPosition.MaxForce = Vector3.new()
                        model:SetAttribute("GluePrimary", true)
                        ChangeSBstate(data.SB, "GluePrimary")
                    else
                        ChangeSBstate(data.SB, "Glue")
                        model:SetAttribute("Glue", true)
                    end
                    
                    if ESPEnabled.Group then
                        CreateESP(model, "Group")
                    end
                    
                    table.insert(groupItems, {
                        model = model,
                        part = anchoredPart,
                        offset = offset,
                        bodypos = data.BodyPosition,
                        bodygyro = data.BodyGyro
                    })
                end
            end
            
            table.insert(CompiledGroups, {
                primaryPart = heldAnchoredModel,
                group = groupItems,
                Nc_Group = {},
                gC = groupConnections,
                gN = groupName
            })
            
            CreateNoCollisionConstraintsCompile(heldAnchoredModel)
            ObjectStateBillboardGUI(heldAnchoredModel, groupName)
            
            updateConnection = game:GetService("RunService").Heartbeat:Connect(function()
                UpdateGroupPositions(heldAnchoredModel)
            end)
            table.insert(groupConnections, updateConnection)
            
            updateCompileGroupsDropdown(CompileGroups_Dropdown)
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Error",
                Text = "You need to hold one of your anchored object",
                Duration = 5
            })
        end
    end
end

function updateCompileGroupsDropdown(dropdown)
    groupNames = {}
    for _, groupData in ipairs(CompiledGroups) do
        table.insert(groupNames, groupData.gN)
    end
    dropdown:Refresh(groupNames, true)
end

imageButtonAnchor = Instance.new("ImageButton")
imageButtonAnchor.Size = UDim2.new(0, 50, 0, 50)
imageButtonAnchor.Position = UDim2.new(1, -325, 1, -80)
imageButtonAnchor.Image = "rbxassetid://9716644"
imageButtonAnchor.BackgroundTransparency = 1
imageButtonAnchor.ImageTransparency = 0.2
imageButtonAnchor.ImageColor3 = Color3.fromRGB(142, 142, 142)
imageButtonAnchor.Visible = false
imageButtonAnchor.Active = false
gui2 = Instance.new("ScreenGui")
gui2.ResetOnSpawn = false
gui2.Name = "CAG2"
gui2.Parent = LocalPlayer.PlayerGui
imageButtonAnchor.Parent = gui2
imageKLabelDe = Instance.new("ImageLabel")
imageKLabelDe.Size = UDim2.new(1, 0, 1, 0)
imageKLabelDe.Image = "rbxassetid://304031128"
imageKLabelDe.BackgroundTransparency = 1
imageKLabelDe.Parent = imageButtonAnchor

imageButtonAnchor.InputBegan:Connect(function(input, processed)
    if not processed and game:GetService("UserInputService").TouchEnabled and input.UserInputType == Enum.UserInputType.Touch then
        anchorfunc()
    end
end)

Section1 = Tab:CreateSection("----")

local AnchorConnection = nil

Toggle1 = Tab:CreateToggle({
    Name = "Anchor Held Object",
    CurrentValue = false,
    Flag = "anchorbind_toggle",
    Callback = function(Value)
        imageButtonAnchor.Visible = Value
        imageButtonAnchor.Active = Value
        
        if Value then
            if AnchorConnection then
                AnchorConnection:Disconnect()
            end

            AnchorConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                if input.KeyCode == Enum.KeyCode.K then
                    anchorfunc()
                end
            end)
          else
            if AnchorConnection then
                AnchorConnection:Disconnect()
                AnchorConnection = nil
            end
        end
    end,
})

ToggleESPAnchored = Tab:CreateToggle({
    Name = "ESP Anchored Objects",
    CurrentValue = false,
    Flag = "esp_anchored_toggle",
    Callback = function(Value)
        ESPEnabled.Anchored = Value
        UpdateAllESP()
    end,
})

ToggleAutoRecover = Tab:CreateToggle({
    Name = "Auto Recover Parts",
    CurrentValue = false,
    Flag = "auto_recover_toggle",
    Callback = function(Value)
        AutoRecoverEnabled = Value
        if Value then
            RecoverCoroutine = coroutine.create(RecoverParts)
            coroutine.resume(RecoverCoroutine)
        else
            if RecoverCoroutine then
                RecoverCoroutine = nil
            end
        end
    end,
})

SectionAppearance = Tab:CreateSection("----")

ColorPickerAnchoredLine = Tab:CreateColorPicker({
    Name = "Anchored Line Color",
    Color = Color3.fromRGB(194, 194, 194),
    Flag = "anchored_line_color",
    Callback = function(Value)
        SB_AnchoredColor3.Value = Value
        for model, data in pairs(AnchoredObjects) do
            if model:GetAttribute("IsAnchored") and not IsInCompileGroup(model) then
                ChangeSBstate(data.SB, "Anchored")
            end
        end
    end
})

ColorPickerAnchoredSurface = Tab:CreateColorPicker({
    Name = "Anchored Surface Color",
    Color = Color3.fromRGB(209, 0, 0),
    Flag = "anchored_surface_color",
    Callback = function(Value)
        SB_AnchoredColor3Surface.Value = Value
        for model, data in pairs(AnchoredObjects) do
            if model:GetAttribute("IsAnchored") and not IsInCompileGroup(model) then
                ChangeSBstate(data.SB, "Anchored")
            end
        end
    end
})

SliderLineTransparency = Tab:CreateSlider({
    Name = "Line Transparency",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = 0,
    Flag = "line_transparency",
    Callback = function(Value)
        SB_LineTransparencyValue.Value = Value
        for model, data in pairs(AnchoredObjects) do
            if data.SB then
                data.SB.Transparency = Value
            end
        end
    end,
})

SliderSurfaceTransparency = Tab:CreateSlider({
    Name = "Surface Transparency",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = 0.5,
    Flag = "surface_transparency",
    Callback = function(Value)
        SB_SurfaceTransparencyValue.Value = Value
        for model, data in pairs(AnchoredObjects) do
            if data.SB then
                data.SB.SurfaceTransparency = Value
            end
        end
    end,
})

Button1 = Tab:CreateButton({
    Name = "Unanchor All",
    Callback = function()
        unAnchorAll()
    end,
})

Section2 = Tab:CreateSection("----")

Button2 = Tab:CreateButton({
    Name = "Stick Group of toys",
    Callback = function()
        CompileObjects()
    end,
})

ToggleESPGroup = Tab:CreateToggle({
    Name = "ESP Compiled Groups",
    CurrentValue = false,
    Flag = "esp_group_toggle",
    Callback = function(Value)
        ESPEnabled.Group = Value
        UpdateAllESP()
    end,
})

SectionGroupAppearance = Tab:CreateSection("----")

ColorPickerGlueLine = Tab:CreateColorPicker({
    Name = "Glue Line Color",
    Color = Color3.fromRGB(255, 0, 57),
    Flag = "glue_line_color",
    Callback = function(Value)
        SB_GlueColor3.Value = Value
        for _, groupData in ipairs(CompiledGroups) do
            for _, item in pairs(groupData.group) do
                if item.model:GetAttribute("Glue") and not item.model:GetAttribute("GluePrimary") then
                    data = AnchoredObjects[item.model]
                    if data then
                        ChangeSBstate(data.SB, "Glue")
                    end
                end
            end
        end
    end
})

ColorPickerGlueSurface = Tab:CreateColorPicker({
    Name = "Glue Surface Color",
    Color = Color3.fromRGB(244, 244, 244),
    Flag = "glue_surface_color",
    Callback = function(Value)
        SB_GlueColor3Surface.Value = Value
        for _, groupData in ipairs(CompiledGroups) do
            for _, item in pairs(groupData.group) do
                if item.model:GetAttribute("Glue") and not item.model:GetAttribute("GluePrimary") then
                    data = AnchoredObjects[item.model]
                    if data then
                        ChangeSBstate(data.SB, "Glue")
                    end
                end
            end
        end
    end
})

ColorPickerMainGlueLine = Tab:CreateColorPicker({
    Name = "Main Glue Line Color",
    Color = Color3.fromRGB(0, 85, 0),
    Flag = "main_glue_line_color",
    Callback = function(Value)
        SB_MainGlueColor3.Value = Value
        for _, groupData in ipairs(CompiledGroups) do
            for _, item in pairs(groupData.group) do
                if item.model:GetAttribute("GluePrimary") then
                    data = AnchoredObjects[item.model]
                    if data then
                        ChangeSBstate(data.SB, "GluePrimary")
                    end
                end
            end
        end
    end
})

ColorPickerMainGlueSurface = Tab:CreateColorPicker({
    Name = "Main Glue Surface Color",
    Color = Color3.fromRGB(89, 225, 65),
    Flag = "main_glue_surface_color",
    Callback = function(Value)
        SB_MainGlueColor3Surface.Value = Value
        for _, groupData in ipairs(CompiledGroups) do
            for _, item in pairs(groupData.group) do
                if item.model:GetAttribute("GluePrimary") then
                    data = AnchoredObjects[item.model]
                    if data then
                        ChangeSBstate(data.SB, "GluePrimary")
                    end
                end
            end
        end
    end
})

CompileGroups_Dropdown = Tab:CreateDropdown({
    Name = "Groups",
    Options = {},
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "compile_groups",
    Callback = function(Option)
        _G.CompileGroupSelected = Option[1] or ""
    end,
})

Button3 = Tab:CreateButton({
    Name = "Delete Group",
    Callback = function()
        if _G.CompileGroupSelected and _G.CompileGroupSelected ~= "" then
            RemoveGroupCompileFromName(_G.CompileGroupSelected)
            updateCompileGroupsDropdown(CompileGroups_Dropdown)
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Error",
                Text = "Select a group first",
                Duration = 3
            })
        end
    end,
})

local TpTab = Window:CreateTab("Teleports", "plane")

local Player = game:GetService("Players").LocalPlayer
local AntiTab = {}

local loopTPEnabled = false

TpTab:CreateToggle({
    Name = "Loop TP",
    CurrentValue = false,
    Callback = function(Value)
        loopTPEnabled = Value

        local char = Player.Character or Player.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")

        if loopTPEnabled then
            if hum then hum.PlatformStand = true end

            task.spawn(function()
                while loopTPEnabled do
                    if not hrp or not hrp.Parent then break end

                    local x = math.random(-500, 500)
                    local y = math.random(30, 480)
                    local z = math.random(-500, 500)
                    hrp.CFrame = CFrame.new(x, y, z)

                    task.wait(0.03)
                end

                if hum then hum.PlatformStand = false end
            end)
        else
            if hum then hum.PlatformStand = false end
        end
    end
})

local tpland = {
    Spawn = CFrame.new(0, -7.35, 0),
    SpawnCave = CFrame.new(-90, 14.6, -314.3),
    GreenHouse = CFrame.new(-538, -7, 74),
    PinkHouse = CFrame.new(-478, -7, -147),
    Barn = CFrame.new(-228, 82, -318),
    BlueHouse = CFrame.new(496, 83, -350),
    ChineseHouse = CFrame.new(542, 123, -93),
    PurpleHouse = CFrame.new(270, -7, 448),
    Factory = CFrame.new(134, 347, 352),
    OtherGreenHouse = CFrame.new(-359, 98, 357),
    BigCave = CFrame.new(-245, 80, 485),
    TrainCave = CFrame.new(536.6, 87.5, -169.5),
    IslandCave = CFrame.new(75.8, 323, 368.5),
    ChineseRoof = CFrame.new(592, 153, -100),
    UfoCave = CFrame.new(29.6, 10.5, -225.8),
    Prison = CFrame.new(195, -7, -561),
    GoodPrison = CFrame.new(569.6, -7, 176.3),
    RuhubsDogAhhPrison = CFrame.new(564, 82.5, 210),
    ExtremelyGoodPrison = CFrame.new(525, 76, 56),

    BlueHouseSlot = CFrame.new(562.2, 85.38, -212.56),
    SpawnSlot = CFrame.new(51.75, -5.3, -121.64),
    HauntedSlot = CFrame.new(164.57, -5.43, 530.97),
    RandomSlot = CFrame.new(-211.65, 85.7, 426.72),
    BeachSlot = CFrame.new(-546.97, -5.3, -41.09),
}

local teleportHistory = {}

function createTpButton(name, location, description)
    TpTab:CreateButton({
        Name = name,
        Callback = function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = location
                table.insert(teleportHistory, location)
                Rayfield:Notify({
                    Title = "Teleportation",
                    Content = player.Name .. " was sent to " .. description,
                    Duration = 6.5,
                    Image = 4483362458,
                })
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Cannot teleport: Character or HumanoidRootPart not found",
                    Duration = 6.5,
                    Image = 4483362458,
                })
            end
        end,
    })
end

createTpButton("Go To Spawn", tpland.Spawn, "Spawn")
createTpButton("Go To SpawnCave", tpland.SpawnCave, "SpawnCave")
createTpButton("Go To GreenHouse", tpland.GreenHouse, "GreenHouse")
createTpButton("Go To PinkHouse", tpland.PinkHouse, "PinkHouse")
createTpButton("Go To Barn", tpland.Barn, "Barn")
createTpButton("Go To BlueHouse", tpland.BlueHouse, "BlueHouse")
createTpButton("Go To ChineseHouse", tpland.ChineseHouse, "ChineseHouse")
createTpButton("Go To PurpleHouse", tpland.PurpleHouse, "PurpleHouse")

TpTab:CreateSection(" ---- ")

createTpButton("Go To Factory", tpland.Factory, "Factory")
createTpButton("Go To OtherGreenHouse", tpland.OtherGreenHouse, "OtherGreenHouse")
createTpButton("Go To BigCave", tpland.BigCave, "BigCave")
createTpButton("Go To TrainCave", tpland.TrainCave, "TrainCave")
createTpButton("Go To IslandCave", tpland.IslandCave, "IslandCave")
createTpButton("Go To ChineseRoof", tpland.ChineseRoof, "ChineseRoof")
createTpButton("Go To UfoCave", tpland.UfoCave, "UfoCave")

TpTab:CreateSection(" ---- ")

createTpButton("Go To Prison", tpland.Prison, "Prison")
createTpButton("Go To GoodPrison", tpland.GoodPrison, "GoodPrison")
createTpButton("Go To RuhubsDogAhhPrison", tpland.RuhubsDogAhhPrison, "RuhubsDogAhhPrison")
createTpButton("Go To ExtremelyGoodPrison", tpland.ExtremelyGoodPrison, "ExtremelyGoodPrison")

TpTab:CreateSection(" ---- ")

createTpButton("Go To BlueHouseSlot", tpland.BlueHouseSlot, "BlueHouseSlot")
createTpButton("Go To SpawnSlot", tpland.SpawnSlot, "SpawnSlot")
createTpButton("Go To HauntedSlot", tpland.HauntedSlot, "HauntedSlot")
createTpButton("Go To RandomSlot", tpland.RandomSlot, "RandomSlot")
createTpButton("Go To BeachSlot", tpland.BeachSlot, "BeachSlot")

TpTab:CreateDivider()

Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer
ReplicatedStorage = game:GetService("ReplicatedStorage")
Workspace = game:GetService("Workspace")

local StatusLabel = TpTab:CreateLabel("Broken: False")

destroyBarrierActive = false
destroyBarrierThread = nil
plotsBroken = false

TpTab:CreateToggle({
    Name = "Break Plot Barriers (Requires Snowball)",
    CurrentValue = false,
    Flag = "DestroyBarrierHouse",
    Callback = function(Value)
        if Value and plotsBroken then
            Rayfield:Notify({
                Title = "Already Broken",
                Content = "Plots are already broken!",
                Duration = 5,
                Image = 4483345998,
                Actions = {
                    Ignore = {
                        Name = "Okay!",
                        Callback = function()
                            print("The user tapped Okay!")
                        end
                    },
                },
            })
            return
        end

        destroyBarrierActive = Value

        if destroyBarrierThread then
            task.cancel(destroyBarrierThread)
            destroyBarrierThread = nil
        end

        if Value then
            local spawnedToysFolder = workspace:FindFirstChild(LocalPlayer.Name.."SpawnedInToys")
            if spawnedToysFolder then
                for _, item in ipairs(spawnedToysFolder:GetChildren()) do
                    if item.Name == "BallSnowball" then
                        ReplicatedStorage.MenuToys.DestroyToy:FireServer(item)
                    end
                end
            end

            if not plotsBroken then
                StatusLabel:Set("Broken: False")
            end

            destroyBarrierThread = task.spawn(function()
                local MenuToys = ReplicatedStorage:WaitForChild("MenuToys")
                local SetNetworkOwner = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
                local DestroyGrabLine = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("DestroyGrabLine")

                local targetCFrame = CFrame.new(264.5792541503906, -5.477070331573486, 433.4557800292969)

                function getSnowballs()
                    local snowballs = {}
                    local spawnedToysFolder = workspace:FindFirstChild(LocalPlayer.Name.."SpawnedInToys")
                    if spawnedToysFolder then
                        for _, toy in ipairs(spawnedToysFolder:GetChildren()) do
                            if toy.Name == "BallSnowball" then
                                table.insert(snowballs, toy)
                            end
                        end
                    end
                    return snowballs
                end

                function spawnSnowball()
                    if not destroyBarrierActive then return end
                    local playerPosition = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart.Position or Vector3.new(0, 0, 0)
                    local initialCFrame = CFrame.new(playerPosition) * CFrame.Angles(-0.807, -0.884, -0.679)
                    task.spawn(function()
                        MenuToys.SpawnToyRemoteFunction:InvokeServer("BallSnowball", initialCFrame, Vector3.new(0, -120.21099853515625, 0))
                    end)
                end

                function processSnowball(snowball)
                    if not destroyBarrierActive then return end
                    local soundPart = snowball:FindFirstChild("SoundPart")
                    if soundPart then
                        task.spawn(function()
                            SetNetworkOwner:FireServer(soundPart, soundPart.CFrame)
                        end)
                    end
                end

                function teleportSnowballs(snowballs)
                    if not destroyBarrierActive then return end
                    for _, snowball in ipairs(snowballs) do
                        task.spawn(function()
                            for _, part in ipairs(snowball:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.CFrame = targetCFrame
                                end
                            end
                        end)
                    end
                end

                function testWithOven()
                    if not destroyBarrierActive then return false end

                    local targetPosition = CFrame.new(242.66055297851562, -9.196549415588379, 444.3758850097656)
                    MenuToys.SpawnToyRemoteFunction:InvokeServer("OvenDarkGray", targetPosition, Vector3.new(0, -74.0790023803711, 0))

                    task.wait(0.5)
                    local spawnedToysFolder = workspace:FindFirstChild(LocalPlayer.Name.."SpawnedInToys")
                    local oven

                    if spawnedToysFolder then
                        for _, child in ipairs(spawnedToysFolder:GetChildren()) do
                            if child.Name == "OvenDarkGray" and child:GetAttribute("AtSpawned") == nil then
                                oven = child
                                break
                            end
                        end
                    end

                    local stillExists = oven ~= nil

                    if stillExists then
                        StatusLabel:Set("Broken: True")
                        plotsBroken = true
                        Rayfield:Notify({
                            Title = "Success!",
                            Content = "The plots have been broken successfully!",
                            Duration = 5,
                            Image = 4483345998,
                            Actions = {
                                Ignore = {
                                    Name = "Awesome!",
                                    Callback = function()
                                        print("The user tapped Awesome!")
                                    end
                                },
                            },
                        })
                    end

                    return stillExists
                end

                while destroyBarrierActive do
                    local snowballs = getSnowballs()

                    if #snowballs < 2 then
                        if #snowballs < 1 then
                            spawnSnowball()
                            task.wait(0.02)
                        end
                        spawnSnowball()
                        task.wait(0.02)
                        snowballs = getSnowballs()
                    end

                    if #snowballs == 2 then
                        for _, snowball in ipairs(snowballs) do
                            processSnowball(snowball)
                        end

                        teleportSnowballs(snowballs)

                        local ovenResult = testWithOven()
                        if ovenResult then
                            break
                        else
                            task.wait(0.05)
                        end
                    end

                    task.wait(0.05)
                end
            end)
        else
            local spawnedToysFolder = workspace:FindFirstChild(LocalPlayer.Name.."SpawnedInToys")
            if spawnedToysFolder then
                for _, item in ipairs(spawnedToysFolder:GetChildren()) do
                    if item.Name == "BallSnowball" or item.Name == "OvenDarkGray" then
                        ReplicatedStorage.MenuToys.DestroyToy:FireServer(item)
                    end
                end
            end
            if not plotsBroken then
                StatusLabel:Set("Broken: False")
            end
        end
    end,
})

local ESP_Tab = Window:CreateTab("ESP", "eye")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local playerHighlights = {}
local playerIcons = {}
local tracerLines = {}

local UIS = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local highlightFillColor = Color3.fromRGB(255, 0, 0)
local highlightOutlineColor = Color3.fromRGB(255, 255, 255)
local tracerColor = Color3.fromRGB(255, 255, 255)

local function createTracer(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = player.Character.HumanoidRootPart

    local line = Drawing and Drawing.new and Drawing.new("Line") or nil
    if not line then
        return
    end

    line.Color = tracerColor
    line.Thickness = 1.5
    line.Transparency = 1

    tracerLines[player] = line
end

local function removeTracer(player)
    local line = tracerLines[player]
    if line then
        pcall(function() line:Remove() end)
        tracerLines[player] = nil
    end
end

local function createHighlight(player)
    if not player.Character then return end
    if playerHighlights[player] then return end
    if player == LocalPlayer then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "RayfieldESP"
    highlight.Adornee = player.Character
    highlight.FillColor = highlightFillColor
    highlight.OutlineColor = highlightOutlineColor
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character

    playerHighlights[player] = highlight
end

local function removeHighlight(player)
    if playerHighlights[player] then
        playerHighlights[player]:Destroy()
        playerHighlights[player] = nil
    end
end

local function createESPIcon(player)
    if not player.Character then return end
    local head = player.Character:FindFirstChild("Head")
    if not head then return end
    if playerIcons[player] then return end
    if player == LocalPlayer then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPIcon"
    billboard.Adornee = head
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 60, 0, 60)
    billboard.StudsOffset = Vector3.new(0, 1.5, 0)
    billboard.Parent = PlayerGui

    local imageLabel = Instance.new("ImageLabel")
    imageLabel.Parent = billboard
    imageLabel.BackgroundTransparency = 1
    imageLabel.Size = UDim2.new(1, 0, 1, 0)
    imageLabel.Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. player.UserId .. "&width=420&height=420&format=png"
    imageLabel.ScaleType = Enum.ScaleType.Fit

    playerIcons[player] = billboard
end

local function removeESPIcon(player)
    if playerIcons[player] then
        playerIcons[player]:Destroy()
        playerIcons[player] = nil
    end
end

local HighlightEnabled = false
local IconEnabled = false
local TracerEnabled = false

ESP_Tab:CreateToggle({
    Name = "Highlight ESP",
    CurrentValue = false,
    Flag = "ESP_Highlight",
    Callback = function(enabled)
        HighlightEnabled = enabled
        if enabled then
            for _, plr in ipairs(Players:GetPlayers()) do
                createHighlight(plr)
            end
        else
            for plr, _ in pairs(playerHighlights) do
                removeHighlight(plr)
            end
        end
    end,
})

ESP_Tab:CreateToggle({
    Name = "Icon ESP",
    CurrentValue = false,
    Flag = "ESP_Icon",
    Callback = function(enabled)
        IconEnabled = enabled
        if enabled then
            for _, plr in ipairs(Players:GetPlayers()) do
                createESPIcon(plr)
            end
        else
            for plr, _ in pairs(playerIcons) do
                removeESPIcon(plr)
            end
        end
    end,
})

ESP_Tab:CreateToggle({
    Name = "Tracers",
    CurrentValue = false,
    Flag = "ESP_Tracers",
    Callback = function(enabled)
        TracerEnabled = enabled
        if not enabled then
            for plr, _ in pairs(tracerLines) do
                removeTracer(plr)
            end
        else
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer then
                    createTracer(plr)
                end
            end
        end
    end,
})

Players.PlayerRemoving:Connect(function(player)
    removeHighlight(player)
    removeESPIcon(player)
    removeTracer(player)
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        if HighlightEnabled then createHighlight(player) end
        if IconEnabled then createESPIcon(player) end
        if TracerEnabled then createTracer(player) end
    end)
end)

RunService.RenderStepped:Connect(function()
    if not TracerEnabled then return end

    local screenCenterX = Camera.ViewportSize.X / 2
    local screenBottomY = Camera.ViewportSize.Y - 20

    for player, line in pairs(tracerLines) do
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            removeTracer(player)
            continue
        end

        local hrp = character.HumanoidRootPart
        local hrpPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        if onScreen and hrpPos.Z > 0 then
            local screenPos = Vector2.new(hrpPos.X, hrpPos.Y)
            line.Visible = true
            line.From = Vector2.new(screenCenterX, screenBottomY)
            line.To = screenPos
        else
            line.Visible = false
        end
    end
end)

ToyTab = Window:CreateTab("Toys", 4483362458)

ToyTab:CreateSection(" ")

TrackedParts = {}
FloatLoops = {}
GravityConnection = nil

CONFIG = { AURA_RADIUS = 30, SCAN_DELAY = 0.1, PER_PART_THROTTLE = 0.2 }
recentParts = {}
ownedParts = {}
auraRunning = false
scanTask = nil

function StopFloat(part)
    if FloatLoops[part] then pcall(function() FloatLoops[part]:Disconnect() end) FloatLoops[part] = nil end
    bv = part:FindFirstChildOfClass("BodyVelocity")
    if bv then bv:Destroy() end
    bav = part:FindFirstChildOfClass("BodyAngularVelocity")
    if bav then bav:Destroy() end
end

function isPlayerPart(part)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and part:IsDescendantOf(plr.Character) then return true end
    end
    return false
end

function isOwned(part)
    owner = part:FindFirstChild("PartOwner")
    return owner and owner.Value == LocalPlayer.Name
end

function claimPartOwner(part)
    if SetNetworkOwner then pcall(function() SetNetworkOwner:FireServer(part, part.CFrame) end) end
    if not TrackedParts[part] then
        bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(1e5, 0, 1e5)
        bv.Velocity = Vector3.zero
        TrackedParts[part] = {bv = bv, bav = bav}
        part.AncestryChanged:Connect(function(_, parent)
            if not parent then StopFloat(part) TrackedParts[part] = nil end
        end)
    end
end

function cleanupOwnedParts()
    for part in pairs(ownedParts) do StopFloat(part) end
    table.clear(ownedParts)
    table.clear(recentParts)
end

function startScanner()
    if scanTask then return end
    scanTask = task.spawn(function()
        while auraRunning do
            char = LocalPlayer.Character
            if char and char.PrimaryPart then
                rootPos = char.PrimaryPart.Position
                parts = Workspace:GetPartBoundsInRadius(rootPos, CONFIG.AURA_RADIUS)
                now = tick()
                for _, part in ipairs(parts) do
                    if part:IsA("BasePart") and not part.Anchored and not isPlayerPart(part) then
                        model = part:FindFirstAncestorWhichIsA("Model")
                        if model then
                            ownedAlready = false
                            for _, p in ipairs(model:GetDescendants()) do
                                if p:IsA("BasePart") and isOwned(p) then ownedAlready = true break end
                            end
                            if not ownedAlready then
                                last = recentParts[part]
                                if (not last) or (now - last > CONFIG.PER_PART_THROTTLE) then
                                    recentParts[part] = now
                                    claimPartOwner(part)
                                end
                            end
                            for _, p in ipairs(model:GetDescendants()) do
                                if p:IsA("BasePart") and isOwned(p) then ownedParts[p] = true end
                            end
                        end
                    end
                end
            end
            task.wait(CONFIG.SCAN_DELAY)
        end
    end)
end

function stopScanner()
    auraRunning = false
    scanTask = nil
end

ToyTab:CreateToggle({
    Name = "Aura (Disable when using something!)",
    CurrentValue = false,
    Flag = "AuraToggle",
    Callback = function(enabled)
        if enabled then
            auraRunning = true
            startScanner()
            Rayfield:Notify({ Title = "Aura Grab", Content = "Started", Duration = 2 })
        else
            stopScanner()
            cleanupOwnedParts()
            Rayfield:Notify({ Title = "Aura Grab", Content = "Stopped", Duration = 2 })
        end
    end
})

HollowPurpleSettings = {
    OrbDistance = 80,
    OrbOffset = 80,
    Height = 5,
    PosX = 0,
    PosY = 0,
    PosZ = 0
}

ToyTab:CreateSection("Hollow Purple Settings")

ToyTab:CreateSlider({
    Name = "Orb Distance",
    Range = {10, 200},
    Increment = 5,
    CurrentValue = 80,
    Flag = "HollowPurpleDistance",
    Callback = function(Value)
        HollowPurpleSettings.OrbDistance = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Orb Offset",
    Range = {10, 200},
    Increment = 5,
    CurrentValue = 80,
    Flag = "HollowPurpleOffset",
    Callback = function(Value)
        HollowPurpleSettings.OrbOffset = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Height",
    Range = {0, 50},
    Increment = 1,
    CurrentValue = 5,
    Flag = "HollowPurpleHeight",
    Callback = function(Value)
        HollowPurpleSettings.Height = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position X",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "HollowPurplePosX",
    Callback = function(Value)
        HollowPurpleSettings.PosX = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Y",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "HollowPurplePosY",
    Callback = function(Value)
        HollowPurpleSettings.PosY = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Z",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "HollowPurplePosZ",
    Callback = function(Value)
        HollowPurpleSettings.PosZ = Value
    end,
})

ToyTab:CreateButton({
    Name = "Hollow Purple...",
    Callback = function()
        char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then return end
        root = char.HumanoidRootPart
        forward = root.CFrame.LookVector
        right = root.CFrame.RightVector
        basePos = Vector3.new(HollowPurpleSettings.PosX, HollowPurpleSettings.PosY, HollowPurpleSettings.PosZ)
        leftOrbPos = basePos + root.Position + forward * HollowPurpleSettings.OrbDistance - right * HollowPurpleSettings.OrbOffset + Vector3.new(0, HollowPurpleSettings.Height, 0)
        rightOrbPos = basePos + root.Position + forward * HollowPurpleSettings.OrbDistance + right * HollowPurpleSettings.OrbOffset + Vector3.new(0, HollowPurpleSettings.Height, 0)
        centerOrbPos = basePos + root.Position + forward * HollowPurpleSettings.OrbDistance + Vector3.new(0, HollowPurpleSettings.Height, 0)
        GatheredParts = {}
        partsList = {}
        for part, _ in pairs(TrackedParts) do
            if part and part:IsDescendantOf(workspace) then StopFloat(part) table.insert(partsList, part) end
        end
        for i, part in ipairs(partsList) do
            orbTarget = (i % 2 == 0) and rightOrbPos or leftOrbPos
            bp = Instance.new("BodyPosition")
            bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bp.D = 1000
            bp.P = 20000
            bp.Position = orbTarget + Vector3.new(math.random(-3, 3), math.random(-2, 2), math.random(-3, 3))
            bp.Parent = part
            GatheredParts[part] = bp
        end
        task.delay(3, function()
            for part, bp in pairs(GatheredParts) do
                bp.Position = centerOrbPos + Vector3.new(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2))
            end
            task.delay(2, function()
                for part, bp in pairs(GatheredParts) do
                    if bp and bp.Parent then bp:Destroy() end
                    blast = Instance.new("BodyVelocity")
                    blast.MaxForce = Vector3.new(1e6, 1e6, 1e6)
                    blast.Velocity = Vector3.new(math.random(-500, 500), math.random(-300, 300), math.random(-500, 500))
                    blast.Parent = part
                    Debris:AddItem(blast, 1)
                end
                table.clear(GatheredParts)
                table.clear(TrackedParts)
            end)
        end)
    end
})

SwastikaSettings = {
    Height = 250,
    Scale = 15,
    PosX = 0,
    PosY = 250,
    PosZ = 0
}

ToyTab:CreateSection("Swastika Settings")

ToyTab:CreateSlider({
    Name = "Scale",
    Range = {5, 50},
    Increment = 1,
    CurrentValue = 15,
    Flag = "SwastikaScale",
    Callback = function(Value)
        SwastikaSettings.Scale = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position X",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "SwastikaPosX",
    Callback = function(Value)
        SwastikaSettings.PosX = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Y",
    Range = {0, 500},
    Increment = 10,
    CurrentValue = 250,
    Flag = "SwastikaPosY",
    Callback = function(Value)
        SwastikaSettings.PosY = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Z",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "SwastikaPosZ",
    Callback = function(Value)
        SwastikaSettings.PosZ = Value
    end,
})

ToyTab:CreateButton({
    Name = "Swastika",
    Callback = function()
        basePos = Vector3.new(SwastikaSettings.PosX, SwastikaSettings.PosY, SwastikaSettings.PosZ)
        scale = SwastikaSettings.Scale
        CUSTOM_9x9 = {
            "100011111",
            "100010000",
            "100010000",
            "100010000",
            "111111111",
            "000010001",
            "000010001",
            "000010001",
            "111110001",
        }
        partsList = {}
        for part, _ in pairs(TrackedParts) do
            if part and part:IsDescendantOf(workspace) then StopFloat(part) table.insert(partsList, part) end
        end
        targetPositions = {}
        height = #CUSTOM_9x9
        width = #CUSTOM_9x9[1]
        for row = 1, height do
            line = CUSTOM_9x9[row]
            for col = 1, width do
                if line:sub(col, col) == "1" then
                    offset = Vector3.new((col - 1 - width / 2) * scale, 0, -(row - 1 - height / 2) * scale)
                    table.insert(targetPositions, basePos + offset)
                end
            end
        end
        if #partsList < #targetPositions then
            Rayfield:Notify({ Title = "Not Enough Pallets", Content = "You need at least " .. tostring(#targetPositions) .. " pallets for this symbol!", Duration = 4 })
        end
        for i, part in ipairs(partsList) do
            target = targetPositions[(i - 1) % #targetPositions + 1]
            bp = Instance.new("BodyPosition")
            bp.MaxForce = Vector3.new(1e9, 1e9, 1e9)
            bp.D = 1000
            bp.P = 50000
            bp.Position = target
            bp.Parent = part
        end
    end
})

TeleportSettings = {
    PosX = 0,
    PosY = 0,
    PosZ = 0
}

ToyTab:CreateSection("Teleport Settings")

ToyTab:CreateSlider({
    Name = "Position X",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "TeleportPosX",
    Callback = function(Value)
        TeleportSettings.PosX = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Y",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "TeleportPosY",
    Callback = function(Value)
        TeleportSettings.PosY = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Z",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "TeleportPosZ",
    Callback = function(Value)
        TeleportSettings.PosZ = Value
    end,
})

ToyTab:CreateButton({
    Name = "Teleport Parts To Point",
    Callback = function()
        targetPosition = Vector3.new(TeleportSettings.PosX, TeleportSettings.PosY, TeleportSettings.PosZ)
        partsList = {}
        for part, _ in pairs(TrackedParts) do
            if part and part:IsDescendantOf(workspace) then StopFloat(part) table.insert(partsList, part) end
        end
        if #partsList == 0 then return end
        for _, part in ipairs(partsList) do
            pcall(function() part.CFrame = CFrame.new(targetPosition) end)
        end
    end
})

OrbitSettings = {
    Radius = 50,
    Speed = 100,
    Height = 3
}

ToyTab:CreateSection("Orbit Settings")

ToyTab:CreateSlider({
    Name = "Radius",
    Range = {10, 200},
    Increment = 5,
    CurrentValue = 50,
    Flag = "OrbitRadius",
    Callback = function(Value)
        OrbitSettings.Radius = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Speed",
    Range = {10, 500},
    Increment = 10,
    CurrentValue = 100,
    Flag = "OrbitSpeed",
    Callback = function(Value)
        OrbitSettings.Speed = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Height Variation",
    Range = {0, 20},
    Increment = 1,
    CurrentValue = 3,
    Flag = "OrbitHeight",
    Callback = function(Value)
        OrbitSettings.Height = Value
    end,
})

ORBIT_RADIUS = 50
ORBIT_SPEED = math.rad(100)
orbitingParts = {}
orbitConnection = nil
orbitEnabled = false

function startOrbit()
    char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    root = char.HumanoidRootPart
    if orbitConnection then orbitConnection:Disconnect() end
    orbitingParts = {}
    for part, _ in pairs(TrackedParts) do
        if part and part:IsDescendantOf(workspace) then orbitingParts[part] = {angle = math.random() * 2 * math.pi} end
    end
    orbitConnection = RunService.Heartbeat:Connect(function(dt)
        time = tick()
        index = 0
        for part, data in pairs(orbitingParts) do
            if part and part.Parent then
                data.angle = data.angle + math.rad(OrbitSettings.Speed) * dt
                x = math.cos(data.angle) * OrbitSettings.Radius
                z = math.sin(data.angle) * OrbitSettings.Radius
                y = math.sin(time + index) * OrbitSettings.Height
                targetPos = root.Position + Vector3.new(x, y, z)
                if part:FindFirstChild("BodyPosition") then
                    part.BodyPosition.Position = targetPos
                else
                    bp = Instance.new("BodyPosition")
                    bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
                    bp.P = 5000
                    bp.D = 100
                    bp.Position = targetPos
                    bp.Parent = part
                end
                index = index + 1
            end
        end
    end)
end

function stopOrbit()
    if orbitConnection then orbitConnection:Disconnect() orbitConnection = nil end
    for part in pairs(orbitingParts) do
        if part and part:FindFirstChild("BodyPosition") then part.BodyPosition:Destroy() end
    end
    orbitingParts = {}
end

ToyTab:CreateToggle({
    Name = "Orbit",
    CurrentValue = false,
    Flag = "OrbitMeToggle",
    Callback = function(enabled)
        orbitEnabled = enabled
        if enabled then startOrbit() else stopOrbit() end
    end
})

TornadoSettings = {
    Height = 200,
    Radius = 100,
    Speed = 200,
    PosX = 0,
    PosY = 0,
    PosZ = 0
}

ToyTab:CreateSection("Tornado Settings")

ToyTab:CreateSlider({
    Name = "Height",
    Range = {50, 500},
    Increment = 10,
    CurrentValue = 200,
    Flag = "TornadoHeight",
    Callback = function(Value)
        TornadoSettings.Height = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Radius",
    Range = {20, 300},
    Increment = 10,
    CurrentValue = 100,
    Flag = "TornadoRadius",
    Callback = function(Value)
        TornadoSettings.Radius = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Speed",
    Range = {50, 500},
    Increment = 10,
    CurrentValue = 200,
    Flag = "TornadoSpeed",
    Callback = function(Value)
        TornadoSettings.Speed = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position X",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "TornadoPosX",
    Callback = function(Value)
        TornadoSettings.PosX = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Y",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "TornadoPosY",
    Callback = function(Value)
        TornadoSettings.PosY = Value
    end,
})

ToyTab:CreateSlider({
    Name = "Position Z",
    Range = {-500, 500},
    Increment = 10,
    CurrentValue = 0,
    Flag = "TornadoPosZ",
    Callback = function(Value)
        TornadoSettings.PosZ = Value
    end,
})

TORNADO_HEIGHT = 200
TORNADO_BASE_RADIUS = 100
TORNADO_SPIN_SPEED = math.rad(200)
tornadoParts = {}
tornadoConnection = nil

function startTornado()
    center = Vector3.new(TornadoSettings.PosX, TornadoSettings.PosY, TornadoSettings.PosZ)
    if tornadoConnection then tornadoConnection:Disconnect() end
    tornadoParts = {}
    for part, _ in pairs(TrackedParts) do
        if part and part:IsDescendantOf(workspace) then tornadoParts[part] = {angle = math.random() * 2 * math.pi, heightOffset = math.random() * TornadoSettings.Height} end
    end
    tornadoConnection = RunService.Heartbeat:Connect(function(dt)
        for part, data in pairs(tornadoParts) do
            if part and part.Parent then
                data.angle = data.angle + math.rad(TornadoSettings.Speed) * dt
                t = data.heightOffset % TornadoSettings.Height
                radius = (t / TornadoSettings.Height) * TornadoSettings.Radius
                x = math.cos(data.angle) * radius
                z = math.sin(data.angle) * radius
                y = t
                targetPos = center + Vector3.new(x, y, z)
                if part:FindFirstChild("BodyPosition") then
                    part.BodyPosition.Position = targetPos
                else
                    bp = Instance.new("BodyPosition")
                    bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
                    bp.P = 5000
                    bp.D = 100
                    bp.Position = targetPos
                    bp.Parent = part
                end
                data.heightOffset = data.heightOffset + 50 * dt
            end
        end
    end)
end

function stopTornado()
    if tornadoConnection then tornadoConnection:Disconnect() tornadoConnection = nil end
    for part in pairs(tornadoParts) do
        if part and part:FindFirstChild("BodyPosition") then part.BodyPosition:Destroy() end
    end
    tornadoParts = {}
end

ToyTab:CreateToggle({
    Name = "Tornado",
    CurrentValue = false,
    Flag = "TornadoToggle",
    Callback = function(enabled)
        if enabled then startTornado() else stopTornado() end
    end
})


game.Players.LocalPlayer.Idled:Connect(function(timeSpentIdle)
   game:GetService("VirtualUser"):CaptureController()
   game:GetService("VirtualUser"):ClickButton2(Vector2.new(0, 0))
end)

Rayfield:Notify({
   Title = "Obsidian Hub Loaded",
   Content = "All features ready!",
   Duration = 3,
   Image = 4483345998,
})

Rayfield:LoadConfiguration()
